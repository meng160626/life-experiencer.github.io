[{"id":"78bf35c97e41da6a2bdad05b63951aa3","title":"函数式编程","content":"一、函数式编程特点1. 原理\n加法结合律 | 因式分解 | 完全平方公式 &#x3D;&gt; 原子组合进行变化 a + b + c &#x3D; (a + b) + c\n\n2. 理论思想\n函数是一等公民 &#x3D;&gt; 将函数视为实际功能逻辑的落脚点 &#x3D;&gt; 实现函数 + 拼接流程\n声明式编程 &#x3D;&gt; 声明需求\n惰性执行 &#x3D;&gt; 无缝连接 性能节约\n\n3. 条件\n无状态\n无副作用\n\n二、实际开发1. 纯函数改造违背纯函数条件的例子\nlet num &#x3D; 1;\nfunction demo(obj) &#123;\n    obj.age +&#x3D; num;\n    &#x2F;&#x2F; 引用了外部变量 有状态 不纯粹\n    &#x2F;&#x2F; 修改了输入参数 有副作用 不纯粹\n&#125;\n\n改造后\nlet num &#x3D; 1;\nfunction demo(obj, num) &#123;\n    return &#123;\n        ...obj,\n        age: obj.age + num\n    &#125;\n&#125;\n\n2. 流水线组装 - 加工 &amp; 拼接加工 - 柯里化&#x2F;&#x2F; f(x, y, z) &#x3D;&gt; f(x)(y)(z)\nconst sum &#x3D; (x, y) &#x3D;&gt; &#123;\n    return x + y;\n&#125;\n\nconst add &#x3D; x &#x3D;&gt; &#123;\n    return y &#x3D;&gt; &#123;\n        return x + y;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 单个函数加工输入输出应该单值化 &#x3D;&gt; 单元函数\n\n面试题 - 实现柯里化的累加函数\nconst add &#x3D; function() &#123;\n    let args &#x3D; Array.prototype.slice.call(arguments);\n    let inner &#x3D; function() &#123;\n        args.push(...arguments);\n        return inner;\n    &#125;\n\n    inner.toString &#x3D; () &#x3D;&gt; &#123;\n        return args.reduce((prev, cur) &#x3D;&gt; prev + cur, 0);\n    &#125;\n\n    return inner;\n&#125;\n\nconsole.log(add(1)(1)(2) + 1);\n&#x2F;&#x2F; 函数的隐式转换 当我们直接将函数参与其他的计算时，函数会默认调用 toString 方法，直接将函数体转换为字符串参与计算\n\n拼装 - 组装函数const compose &#x3D; (f, fn) &#x3D;&gt; f(fn(x));\n\nconst add1 &#x3D; x &#x3D;&gt; x + 1;\nconst add2 &#x3D; x &#x3D;&gt; x + 2;\n\nconst add &#x3D; compose(add1, add2);\n\n实际使用&#x2F;&#x2F; 命令式\ntrim(reverse(toUpperCase(map(arr))));\n\n&#x2F;&#x2F; 面向对象\narr.map().toUpperCase().reverse().trim();\n\n&#x2F;&#x2F; 函数式\ncompose(trim, reverse, toUpperCase, map);\n&#x2F;&#x2F; 忽略中间过程，面向函数的流水线","slug":"函数式编程/index","date":"2023-07-22T16:00:00.000Z","categories_index":"效率优化","tags_index":"JS,函数式编程","author_index":"Life Experiencer"},{"id":"f088523d700dba81d882acdf8af76d34","title":"JS 性能优化","content":"性能优化\nNavigation Timing API\nnavigationStart &#x2F; end\n\n表示从上一个文档卸载结束时 &#x3D;&gt; 如果没有上一个文档，这个值和fetchStart相等\n\nunloadEventStart &#x2F; end\n\n标识一个网页unload的时间点 &#x3D;&gt; 如果没有上一个文档，则差值为0\n\nredirectStart &#x2F; end\n\n第一个HTTP重定向发生和结束的时间\n\nfetchStart\n\n浏览器准备好使用请求获取文档的时间\n\ndomainLookupStart &#x2F; end\n\nHTTP开始建立连接的时间\n\nconnectStart &#x2F; end\n\nTCP开始建立连接的时间\n\nsecureConnectionStart &#x2F; end\n\nHTTPS连接开始的时间\n\nrequestStart &#x2F; end\nresponseStart &#x2F; end\n\n网络请求响应的时间\n\ndomLoading\n\n开始解析渲染DOM树的时间 &#x3D;&gt; document.readyState变成loading &#x3D;&gt; 抛出钩子 readystatechange\n\ndomInteractive\n\n完成解析 &#x3D;&gt; 对dom树解析完成\n\ndomContentLoadedEventStart &#x2F; end\n\n加载网页内资源的时间\n\ndomComplete\n\nDom完全解析完成\n&#x2F;&#x2F; 拿到页面解析完整时长\ndocument.addEventListener(&quot;readystatechange&quot;, e &#x3D;&gt; &#123;\n    if (document.readyState &#x3D;&#x3D;&#x3D; &#39;complete&#39;) &#123;\n        var perfData &#x3D; window.performance.timing;\n        var pageLoadTime &#x3D; perfData.domComplete - perfData.navigationStart;\n        console.log(&quot;页面加载耗时：&quot;, pageLoadTime, &#39;ms&#39;);\n    &#125;\n&#125;);\n\n&#x2F;&#x2F; 平均值、实时值\n\nCore Web Vitals - 网页核心性能指标Google提出的三个指标，每一个都代表了用户体验的不同方面 —— 加载、交互、视觉稳定性\nLargest Contentful Paint (LCP)衡量装载性能: LCP应该在页面首次开始加载后2.5s内发生\n\n前2.5s进行最大内容的渲染\n\na. 最大内容包含了哪些？\n\n&lt;img&gt;\n&lt;svg&gt;\n&lt;video&gt;\n通过url函数加载的背景图片\n包含了大块内嵌内容的块级元素\n\nb. LCP值低下的原因？\n\n服务器响应慢\n资源的加载时间过长\n存在阻断渲染的Javascript | CSS\n客户端渲染机器的影响\n\nc. 针对性改造\n\n服务器的优化\n\n缓存HTML离线页面，缓存页面资源，减少浏览器直接对资源的请求 &#x3D;&gt; 缓存机制\n对图片的优化，进行图片合理化使用，降低图片大小，加快请求速度 &#x3D;&gt; 图片上传格式 | 云资源管理\n重写、压缩、注释过滤等方式减少最终文件大小，加快加载速度 &#x3D;&gt; webpack vite 工程化打包\n使用CDN —— 物理上接近请求点\n\n渲染阻断优化\n\nCSS + JS &#x3D;&gt; 延迟处理\n首屏优化 &#x3D;&gt; 懒加载、异步加载\nCSS模块化SSR服务端渲染\nFirst Input Delay (FID)衡量交互性: 页面的首次输入延迟应该小于100ms\n原因: 执行阻塞\na. 减少JS执行时间\n\n缩小压缩JS文件\n延迟加载不需要的JS &#x3D;&gt; 模块懒加载 | tree shaking\n尽量减少未使用的polyfill\n\nb. 分解耗时任务\n\n减少长逻辑\n异步化\n\nc. workerweb worker | service worker\nCumulative Layout Shift (CLS)测量视觉稳定性: 页面稳定性在加载过程中以及渲染后CLS小于0.1 &#x3D;&gt; 整体布局的移动可能发生在可见元素从一帧到下一帧改变位置的任何阶段\na. 会带来偏移的因素？\n\n图片\n内容插入\n字体\n\nb. 针对性解决？- 不使用无尺寸元素 &#x3D;&gt; srcset &amp; sizes\n整体化内容插入 &#x3D;&gt; 避免频繁影响整体布局 &#x3D;&gt; 避免回流\n动态字体控制\n\n性能评估神器 - performance性能监控体系数据采集 &#x3D;&gt; 汇总展示\n\n埋点上报 &#x3D;&gt; 点到点 + 信息采集\n数据处理 &#x3D;&gt; 阈值设置 + 数据分类 + 数据重组\n可视化展示\n\n评估\n\n根据指标要求进行数据圈层 &#x3D;&gt; 数据归档\n定位问题\n\n指导提升\n\n告警处理\n触发分派\n\n","slug":"JS性能优化/index","date":"2023-07-22T16:00:00.000Z","categories_index":"效率优化","tags_index":"JS,性能优化","author_index":"Life Experiencer"},{"id":"8b52d758712f8281d95dde7e25dd1780","title":"前端知识点之浏览器相关","content":"浏览器相关1. BOM1.1 locationlocation.href &#x3D;&gt; ‘https://www.xxx.com/search?class=browser#comments‘    .origin &#x3D;&gt; https://www.xxx.com    .protocal &#x3D;&gt; https    .host &#x3D;&gt; www.xxx.com    .port &#x3D;&gt; ‘’    .pathname &#x3D;&gt; &#x2F;search&#x2F;    .search &#x3D;&gt; ?class&#x3D;browser    .hash &#x3D;&gt; #comments\nlocation.assign(‘url’) 跳转到指定path，并替换pathname &#x3D;&gt; 处理path    .replace(‘url’) 重定向，视觉效果同上，并同时替换浏览历史    .reload() 重新加载当前页面    .toString() 转换成字符串\n1.2 historyhistory.state &#x3D;&gt; 存储获取当前页面状态    .replaceState &#x3D;&gt; 替换当前状态\n1.3 navigatornavigator.userAgent 获取用户信息    .clipboard 剪切板对象\n1.4 screen获取显示区域 —— 屏幕\n考察点：判断区域大小\n&#x2F;&#x2F; window 视窗判断 全局入口处\nwindow.innerHeight\nwindow.innerWidth\n\n&#x2F;&#x2F; window 视窗判断 文本处获取\ndocument.documentElement.clientHeight\ndocument.documentElement.clientWidth\n\n&#x2F;&#x2F; 网页内容size\ndocument.documentElement.offsetHeight\ndocument.documentElement.offsetWidth\n\n&#x2F;&#x2F; 定位\nscrollLeft &#x2F; scrollTop - 元素自己产生滚动条以后，当前可视区域对于其自己内部的左&#x2F;上的距离\noffsetLeft &#x2F; offsetTop - 距离文档左&#x2F;上距离\n\n\n2. 事件模型&lt;body&gt;\n    &lt;div&gt;\n        &lt;span&gt;&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n冒泡: span -&gt; div -&gt; body -&gt; html -&gt; document捕获: document -&gt; html -&gt; body -&gt; div -&gt; span\n阻止事件传播event.stopPropagation();\n阻止默认事件event.preventDefault();\n阻止同节点同类事件后续绑定事件event.stopImmediatePropagation();\n事件绑定性能优化&#x2F;&#x2F; 为li添加事件\nlet liArr &#x3D; list.getElementsByTagName(&#39;li&#39;);\n&#x2F;&#x2F; 原始版本\nfor(let i &#x3D; 0; i &lt; liArr.length; i++) &#123;\n    liArr[i].addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;&#125;);\n&#125;\n&#x2F;&#x2F; 优化版本 利用冒泡\nfunction onClick(e) &#123;\n    let e &#x3D; e || window.event;\n    if (e.target.nodeName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;\n        let index &#x3D; Array.prototype.indexOf.call(liArr, e.target);\n        &#x2F;&#x2F; ……\n    &#125;\n&#125;\ndocument.querySelector(&#39;ul&#39;).addEventListener(&#39;click&#39;, onClick);\n\n3. 网络&#x2F;&#x2F; 1. 实例化\nconst xhr &#x3D; new XMLHttpRequest();\n\n&#x2F;&#x2F; 2. 初始化连接\nxhr.open(method, url, async);\n\n&#x2F;&#x2F; 3. 发送请求\n&#x2F;&#x2F; post时 data被转为 body请求体\n&#x2F;&#x2F; get时 data传空值\n&#x2F;&#x2F; 不管请求方式是什么，都需要encodeURIComponent进行转码\nxhr.send(data);\n\n&#x2F;&#x2F; 4. 接收\nxhr.readyStatus\n&#x2F;&#x2F; 0 - 尚未调用open\n&#x2F;&#x2F; 1 - 已调用open\n&#x2F;&#x2F; 2 - 已调用send\n&#x2F;&#x2F; 3 - 已接收请求返回数据\n&#x2F;&#x2F; 4 - 已完成请求\n\nxhr.onreadystatechange &#x3D; () &#x3D;&gt; &#123;\n    if (xhr.readyStatus &#x3D;&#x3D;&#x3D; 4) &#123;\n        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n            &#x2F;&#x2F; ……\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 超时\nxhr.timeout &#x3D; 1000;\nxhr.ontimeout &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; ……\n&#125;","slug":"前端知识点之浏览器相关/index","date":"2023-07-16T16:00:00.000Z","categories_index":"知识点","tags_index":"面试题,浏览器,js","author_index":"Life Experiencer"},{"id":"c99a5fe4a5656caa27d2f9936274bd86","title":"前端知识点之JS汇总篇","content":"1. 作用域 + 上下文    console.log(&#39;a&#39;);\n    console.log(c);\n    console.log(d);\n\n    let c &#x3D; &#39;c&#39;;\n    var d &#x3D; &#39;d&#39;;\n    demo();\n    function demo() &#123;\n        console.log(&#39;b&#39;);\n&#125;\n这里的demo可以正常执行是函数提升，在同作用域内，执行在声明之前可以正常执行，但超出作用于的提前使用无效变量c打印会报错c is not defined，但d会打印，结果显示为undefined，是因为用var声明变量可以进行变量声明提升（提升声明，但不能提升赋值）\nconsole.log(demo);      &#x2F;&#x2F; ƒ demo() &#123;console.log(1);&#125;\nfunction demo() &#123;\n    console.log(1);\n&#125; \ndemo &#x3D; &#39;demo&#39;;\nconsole.log(demo);      &#x2F;&#x2F; demo\n\n提升优先级 变量优先：会优先显示函数，因为先声明了变量，然后函数对同名变量进行了赋值，走到变量赋值的语句后，又对变量进行了覆盖，最后打印出来会是变量\n2. this 上下文contextthis是在执行时动态读取上下文决定的，而不是创建时\nfunction fn() &#123;\n    console.log(this);  &#x2F;&#x2F; window\n&#125;\nfn();\nthis指向函数的调用者也就是window\n隐式绑定 —— this指代调用堆栈的上一级 &#x3D;&gt; 对象、数组等引用关系逻辑function fn() &#123;\n    console.log(this.a);\n&#125;\nconst obj &#x3D; &#123;\n    a: 1,\n    fn\n&#125;\nobj.fn();           &#x2F;&#x2F; 1\n\n显示绑定 (bind | apply | call)function fn() &#123;\n    console.log(this);\n&#125;\n\nfn.call(&#123;\n    a: 1\n&#125;);\n\nfn.apply(&#123;\n    a: 1\n&#125;);\n\nconst bindFn &#x3D; fn.bind(&#123;\n    a: 1\n&#125;);\nbindFn();\n\n面试题 call、apply、bind的区别function demo(arg1, arg2) &#123;\n    return [arg1, arg2];\n&#125;\n\ndemo.call(1, 2);\ndemo.apply([1, 2]);\nconst tempFn &#x3D; demo.bind(this, 1, 2);\ntempFn();\n\n\ncall和apply都是以当前上下文(作用域)直接执行该函数，但区别是传参方式，call是依次传入&#x2F;apply是数组传入\nbind则是传入一个上下文环境(作用域)，返回一个待执行函数，需要再次调用该函数来得到结果\n\n手写题 实现一个bind&#x2F;&#x2F; 1. bind函数所处的位置 &#x3D;&gt; Function.prototype\nFunction.prototype.myBind &#x3D; function() &#123;\n    &#x2F;&#x2F; 2. 接收新的作用域和参数\n    const args &#x3D; Array.prototype.slice.call(arguments);\n    const newThis &#x3D; args.shift() || window;\n    &#x2F;&#x2F; 3. 将函数挂载在新的作用域上\n    newThis.tempFn &#x3D; this;\n    &#x2F;&#x2F; 4. 返回待执行函数\n    return function() &#123;\n        &#x2F;&#x2F; 5. 执行后需要清空内存\n        const result &#x3D; args[0] ? newThis.tempFn(...args) : newThis.tempFn();\n        delete newThis.tempFn;\n        return result;\n    &#125;\n&#125;\n\nfunction demo() &#123;\n    return this.a;\n&#125;\n\nconsole.log(demo.myBind(&#123;\n    a: 1\n&#125;)());\n\n3. 闭包闭包: 一个函数和他周围环境状态捆绑在一起的组合\n&#x2F;&#x2F; 函数作为返回值的场景\nfunction demo() &#123;\n    let content &#x3D; &#39;内容&#39;;\n    return function() &#123;\n        return content;\n    &#125;\n&#125;\nconst temp &#x3D; demo;\ntemp();                     &#x2F;&#x2F; 内容\n\n&#x2F;&#x2F; 函数作为参数的时候\nlet content &#x3D; 1;\nfunction demo(fn) &#123;\n    let content &#x3D; 2;\n    fn();\n&#125;\nfunction test() &#123;\n    console.log(content);\n&#125;\ntest();                     &#x2F;&#x2F; 1\ndemo(test);                 &#x2F;&#x2F; 1\n&#x2F;&#x2F; 这里的test形成了window的闭包函数，也是因为content在demo内部，作用域无法作用到声明在window中的test函数\n\n4. 面向对象什么是对象？\n\n\n\n\n\n\n\n\n通过代码抽象，进而描述单个种类物体的方式\n\n对象是对于单个物体的简单抽象\n对象是容器，封装了属性 &amp; 方法\n\n属性: 对象的状态方法: 对象的能力 &amp; 行为\n面向对象特点\n逻辑迁移更加灵活\n代码复用性更高\n高度模块化\n\n构造函数\n提供一个模板（类） —— 表征了一类物体的共同特性，从而生成对象\njs本质不是基于类，而是基于构造函数 + 原型链\n\nfunction People() &#123;\n    this.name &#x3D; &#39;李四&#39;;\n    this.eat &#x3D; food &#x3D;&gt; &#123;\n        return &#96;吃$&#123;food&#125;&#96;;\n    &#125;\n&#125;\n\nconst people &#x3D; new People();\n\n追问：如果不使用new进行初始化，构造函数还能具有相同的能力吗？\n\n\n\n\n\n\n\n\n不能，如果不添加new关键字，就只是一个普通函数\nnew是什么？&#x2F; new原理？&#x2F; new的时候做了什么？\n结构上: 创建了一个空对象，作为返回的对象实例\n属性上: 将生成空对象的原型对象指向了构造函数的prototype属性\n关系上: 将当前实例对象赋给了内部的this\n生命周期上: 执行了构造函数的初始化代码\n\nconstructor是什么？\n每个对象在创建时，会自动拥有一个构造函数属性constructor\nconstructor源自原型对象，指向了构造函数的引用\n\nfunction Demo() &#123;\n\n&#125;\nconst demo &#x3D; new Demo();\n\ndemo.__proto__.constructor &#x3D;&#x3D;&#x3D; Demo;\n\n原型对象是什么？\n在使用new创建对象时，将生成空对象的原型对象指向构造函数的prototype属性，这里产生了原型对象\n是对象和构造函数之间的联系\n\nfunction Demo() &#123;\n\n&#125;\nconst demo &#x3D; new Demo();\n\ndemo.__proto__ &#x3D;&#x3D;&#x3D; Demo.prototype;\n\n思考：对象的原型对象的原型对象是什么？function Demo() &#123;\n\n&#125;\nconst demo &#x3D; new Demo();\n\ndemo.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype;  &#x2F;&#x2F; 也同时解释了自定义对象中的一些非自定义属性和方法的来源\n\nObject.prototype.__proto__ &#x3D;&#x3D;&#x3D; null;        &#x2F;&#x2F; 万物皆null\n\n\n\n\n\n\n\n提示\n以上就是原型链\n\n5. 继承5.1 原型链继承function Fath() &#123;\n    this.name &#x3D; &#39;父亲&#39;;\n&#125;\nfunction Son() &#123;\n    \n&#125;\n\nSon.prototype &#x3D; new Fath();\nSon.prototype.constructor &#x3D; Son;    &#x2F;&#x2F; 如果不将构造函数指回来，原型链会错乱\n\nconst son &#x3D; new Son();\n\n&#x2F;&#x2F; 原型链式继承，通过修改原型对象的方式，达到继承的目的\n\n弊端function Fath() &#123;\n    this.name &#x3D; &#39;父亲&#39;;\n    this.sons &#x3D; [];\n&#125;\nfunction Son() &#123;\n    \n&#125;\n\nSon.prototype &#x3D; new Fath();\nSon.prototype.constructor &#x3D; Son;\n\nconst son1 &#x3D; new Son();\nconst son2 &#x3D; new Son();\n\nconsole.log(son1);  &#x2F;&#x2F; Son &#123;&#125;\n&#x2F;&#x2F; 父类属性在原型对象中，不在创建对象中\n\nson1.sons.push(&#39;xxx&#39;);\nconsole.log(son2.sons);     &#x2F;&#x2F; [&#39;xxx&#39;]\n&#x2F;&#x2F; 因为这里的son1和son2的sons属性，都是使用的其原型链上的属性，所以这里的sons指向的是同一个地址，起不到对象的属性隔离作用\n\nson1.name &#x3D; &#39;yyy&#39;;\nconsole.log(son1.name);     &#x2F;&#x2F; yyy\n&#x2F;&#x2F; 这里修改成功是因为js的机制导致创建了一个新的属性，实际未修改到目标属性\nconsole.log(son1.__ptoto__.name);       &#x2F;&#x2F; 父亲\n&#x2F;&#x2F; 原型链继承方式中，父类并不能接收子类的属性修改\n\n\n产生了子类的共享属性，无法隔离\n子项无法修改父类属性，又不能通过创建时传递参数的方式修改\n\n5.2 构造函数继承function Fath() &#123;\n    this.name &#x3D; &#39;父亲&#39;;\n    this.sons &#x3D; [];\n&#125;\nfunction Son(arg) &#123;\n    Fath.call(this, arg);\n&#125;\n\nconst son &#x3D; new Son();\n\nconsole.log(son);   &#x2F;&#x2F; Son &#123;name: &#39;父亲&#39;, sons: Array(0)&#125;\n\n&#x2F;&#x2F; 同时解决了共享属性 + 子向父传参的问题\n\n弊端function Fath() &#123;\n    function work() &#123;\n\n    &#125;\n&#125;\nfunction Son(arg) &#123;\n    Fath.call(this, arg);\n&#125;\nconst son &#x3D; new Son();\nson.work();         &#x2F;&#x2F; 报错\n\n&#x2F;&#x2F; 无法继承其父类的函数\n\n5.3 组合继承function Fath() &#123;\n    function work() &#123;\n\n    &#125;\n&#125;\nfunction Son(arg) &#123;\n    Fath.call(this, arg);\n&#125;\nSon.prototype &#x3D; new Fath();\nSon.prototype.constructor &#x3D; Son;\nconst son &#x3D; new Son();\n\n弊端function Fath() &#123;\n    console.log(&#39;父类构造&#39;);\n&#125;\nfunction Son(arg) &#123;\n    Fath.call(this, arg);\n&#125;\nSon.prototype &#x3D; new Fath();\nSon.prototype.constructor &#x3D; Son;\nconst son &#x3D; new Son();\n\n&#x2F;&#x2F; 结果：父类构造 打印两次\n无论何种场景，父类构造都会被调用两次\n5.4 寄生组合继承function Fath() &#123;\n&#125;\nfunction Son(arg) &#123;\n    Fath.call(this, arg);\n&#125;\nSon.prototype &#x3D; Object.create(Fath.prototype);\nSon.prototype.constructor &#x3D; Son;\nconst son &#x3D; new Son();\n\n6. 异步面试题：浏览器的多个窗口是不同线程还是不同进程？多个窗口之间靠什么进行通信？\n\n\n\n\n\n\n\n\n进程storage或者cookie\n发散：多种存储的区别？sessionstorage和localstorage是生命周期的区别storage和cookie是大小长度的区别，跟后台强相关的内容如身份验证等一般用cookie，因为后端可以读写cookie，前端可以通过设置来让每个请求都附带cookie\n6.1 浏览器原理\n6.2 宏任务和微任务宏任务(macro task): script setTimeout setInterval I/O微任务(micro task): promise defineProperty Proxy\n\nsetTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;setTimeout&#39;);          &#x2F;&#x2F; 5. 宏任务2\n&#125;, 0);\n\nnew Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;new Promise&#39;);         &#x2F;&#x2F; 1. 宏任务1\n    resolve();\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;Promise then&#39;);        &#x2F;&#x2F; 3. 微任务1\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;Promise then then&#39;);   &#x2F;&#x2F; 4. 微任务2\n&#125;);\n\nconsole.log(&#39;normal&#39;);                  &#x2F;&#x2F; 2. 宏任务1\n\n6.3 Promise\n\n\n\n\n\n\n\n\nPromise的出现就是为了解决在异步过程中的回调地狱问题\nsetTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;step1&#39;);\n\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#39;step2&#39;);\n        \n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(&#39;step3&#39;);\n        &#125;, 0);\n    &#125;, 0);\n&#125;, 0);\n\nnew Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;step1&#39;);\n    resolve();\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;step2&#39;);\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;step3&#39;);\n&#125;);\n\n&#x2F;&#x2F; Promise API\n&#x2F;&#x2F; 全部执行完毕回调\nPromise.all([func, func...]).then(result &#x3D;&gt; &#123;\n    console.log(&#39;all end&#39;, result);\n&#125;);\n&#x2F;&#x2F; 有任意执行完成的，立刻回调\nPromise.race([func, func...]).then(result &#x3D;&gt; &#123;\n    console.log(&#39;race end&#39;, result);\n&#125;);\n\nPromise 状态\npending 待定(默认状态)\nfulfilled 已兑现\nrejected 已拒绝\n\nPromise 返回返回一个带有then方法，且能接收onFulfilled和onRejected的对象\n手写 Promiseconst PENDING &#x3D; &#39;PENDING&#39;;\nconst FULFILLED &#x3D; &#39;FULFILLED&#39;;\nconst REJECTED &#x3D; &#39;REJECTED&#39;;\n\nclass Promise &#123;\n    constructor(executor) &#123;\n        &#x2F;&#x2F; 实现默认状态为PENDING\n        this.status &#x3D; PENDING;\n\n        &#x2F;&#x2F; 内部维护的变量\n        this.value &#x3D; undefined;\n        this.reason &#x3D; undefined;\n\n        &#x2F;&#x2F; 存放传入的回调函数\n        this.onFulfilledCallbacks &#x3D; [];\n        this.onRejectedCallbacks &#x3D; [];\n\n        &#x2F;&#x2F; 回调函数\n        this.resolve &#x3D; value &#x3D;&gt; &#123;\n            if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123;\n                this.status &#x3D; FULFILLED;\n                this.value &#x3D; value;\n                this.onFulfilledCallbacks.forEach(fn &#x3D;&gt; fn());\n            &#125;\n        &#125;\n        this.reject &#x3D; reason &#x3D;&gt; &#123;\n            if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123;\n                this.status &#x3D; REJECTED;\n                this.reason &#x3D; reason;\n                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());\n            &#125;\n        &#125;\n\n        try &#123;\n            executor(this.resolve, this.reject);\n        &#125; catch (e) &#123;\n            this.reject(e);\n        &#125;\n    &#125;\n\n    then(onFulfilled, onRejected) &#123;\n        try &#123;\n            if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n                onFulfilled(this.value);\n            &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECTED) &#123;\n                onRejected(this.reason);\n            &#125; else &#123;\n                this.onFulfilledCallbacks.push(() &#x3D;&gt; &#123;\n                    onFulfilled(this.value);\n                &#125;);\n                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;\n                    onRejected(this.reason);\n                &#125;);\n            &#125;\n        &#125; catch(e) &#123;\n            this.reject(e);\n        &#125;\n    &#125;\n&#125;\n\n7. JS 模块化目标\n隔离每个模块的逻辑和作用域\n扩展共同协作的方便程度&#x3D;&gt; 可以将无数模块进行随意组装&#x3D;&gt; 万物皆模块&#x3D;&gt; 前端工程化\n\n历史本身定位: 简单的页面实际 —— 页面简单动画 + 基本的表单提交并无模块化 or 命名空间的概念\n幼年期: 无模块化\n开始需要在页面中增加一些不同的js: 动画、表单、格式化工具\n多种js文件被分在不同文件中\n不同的文件又被同一个模板所引用\n\n被视为是模块化的第一步，是最基础的模块化问题在于：易污染全局作用域 &#x3D;&gt; 不利于大型项目的开发，以及多人团队共建\n成长期: 模块化雏形 —— IIFE(语法侧自救)本质是: 对作用域的把控\n利用函数独立作用域的特性\n&#x2F;&#x2F; 定义一个全局变量\nlet count &#x3D; 0;\nconst increase &#x3D; () &#x3D;&gt; count++;\nconst reset &#x3D; () &#x3D;&gt; count &#x3D; 0;\n\n&#x2F;&#x2F; 演变为\nconst module &#x3D; (() &#x3D;&gt; &#123;\n    let count &#x3D; 0;\n    &#x2F;&#x2F; 主流程 功能\n    return &#123;\n        increase: () &#x3D;&gt; count++;\n        reset: () &#x3D;&gt; &#123;\n            count &#x3D; 0;\n        &#125;\n    &#125;\n&#125;)();\nmodule.increase();\nmodule.reset();\n&#x2F;&#x2F; 定义逻辑 + 立即执行 &#x3D;&gt; 独立的空间\n\n&#x2F;&#x2F; 优化: 能够依赖其他模块的IIFE\nconst iifeModule &#x3D; ((depModule1, depModule2) &#x3D;&gt; &#123;\n    return &#123;\n\n    &#125;\n&#125;)(depencencyModule1, depencencyModule2);\n\n成熟期CJS - commonjs(node.js制订)特征: \n\n通过 module + export 去对外暴露接口\n通过 require 进行其他模块的调用\n\n优点: \n\n\n\n\n\n\n\n\n\nCJS率先在服务侧实现了从框架层面解决依赖、模块化的问题\n缺憾: \n\n\n\n\n\n\n\n\n\n针对的是服务端，对于异步依赖没有很友好地处理解决\nAMD 规范\n\n\n\n\n\n\n\n\n通过异步加载 + 允许定制回调函数\n经典框架: require.js\ndefine(id, [depModule], callback);\nrequire([module], callback);\n\ndefine(&#39;amdModule&#39;, [depmodule1, depmodule2], (depModule1, depModule2) &#x3D;&gt; &#123;\n    let count &#x3D; 0;\n    const temp &#x3D; &#123;\n        increase: () &#x3D;&gt; count++;\n        reset: () &#x3D;&gt; count &#x3D; 0;\n    &#125;\n&#125;);\n\n&#x2F;&#x2F; 使用\nrequire([&#39;amdModule&#39;], amdModule &#x3D;&gt; &#123;\n    amdModule.increase();\n&#125;);\n优点: \n\n\n\n\n\n\n\n\n\n解决了浏览器中异步加载模块，可以并行加载多个模块\n缺憾: \n\n\n\n\n\n\n\n\n\n会有引入成本，缺少考虑按需加载\n利用AMD进行逻辑外壳封装define(&#39;amdModule&#39;, [depModule1, depModule2], (depModule1, depModule2) &#x3D;&gt; &#123;\n    let count &#x3D; 0;\n    const temp &#x3D; &#123;\n        increase: () &#x3D;&gt; count++;\n        reset: () &#x3D;&gt; &#123;\n            count &#x3D; 0;\n            &#x2F;&#x2F; fn(depModule1);\n            &#x2F;&#x2F; depModule1, depModule2\n        &#125;\n    &#125;\n\n    return &#123;\n        increase,\n        reset\n    &#125;\n&#125;);\n\n利用代码兼容AMD和CJS (UMD的出现)(function() &#123;\n\n&#125;)(\n    &#x2F;&#x2F; 一次性区分CJS和AMD\n    &#x2F;&#x2F; 1. CJS factory\n    &#x2F;&#x2F; 2. module &amp; module exports\n    &#x2F;&#x2F; 3. define\n    typeof module &#x3D;&#x3D;&#x3D; &quot;Object&quot;\n        &amp;&amp; module.exports\n        &amp;&amp; typeof define !&#x3D;&#x3D; &quot;function&quot;\n            ? &#x2F;&#x2F; 是CJS\n                factory &#x3D;&gt; module.export &#x3D; factory(require, exports, module);\n            : &#x2F;&#x2F; 是CMD\n                define\n);\n\nCMD 规范 - sea.jsdefine(&#39;module&#39;, (require, exports, module) &#x3D;&gt; &#123;\n    let $ &#x3D; require(&#39;jquery&#39;);\n    let depModule1 &#x3D; require(&#39;.&#x2F;dependencyModule1&#39;);\n&#125;);\n\n优点: \n\n\n\n\n\n\n\n\n\n按需加载，依赖就近\n缺憾: \n\n\n\n\n\n\n\n\n\n依赖打包，加载逻辑存在于每个模块中，扩大了模块的体积\nESM新增定义：引入——import导出——export\nimport depModule1 from &#39;.&#x2F;dependencyModule1&#39;;\n\nlet count &#x3D; 0;\nfunction increase() &#123;\n    count++;\n&#125;\n\nexport default &#123;\n    increase\n&#125;\n\n&#x2F;&#x2F; 异步加载\nimport(&#39;.&#x2F;demo.js&#39;).then(demo &#x3D;&gt; &#123;\n    demo.default.fn();\n&#125;);","slug":"前端知识点之JS汇总篇/index","date":"2023-07-01T16:00:00.000Z","categories_index":"知识点","tags_index":"JS,面试题","author_index":"Life Experiencer"},{"id":"59630f6cb50b5d1b95c17c1cbb07d624","title":"前端知识点之CSS汇总篇","content":"1. 布局技巧使用text-align-last对其两端文本\n使用:not()选择器去除无用属性\n多行文本溢出省略号\n2. 事件技巧使用pointer-events禁用事件触发，场景：例如背景为地图，上层有图表的大屏看板\n使用:hover描绘鼠标跟随\n3. 面试题1. absolute是根据哪个元素进行定位的最近的非static的祖先元素，可以是relative，absolute，fixed，一直往上直到找到body停止通常会采用relative+absolute的方式布局绝对定位有一个好处就是可以避免触发回流，因为其脱离了正常的标准文档流，所以对于频繁触发回流的元素可以采用绝对定位来进行优化。\n2. 什么是DPR？像素是显示图像的基本单位，然而1css像素并不完全等于1物理像素，因为物理像素越高显示的内容越清晰，DPR就是物理像素&#x2F;css像素，表达了在某设备上物理像素和css像素的关系。\n3. 1px问题在高清屏中DPR可能为2或3，这时候设置边框为1px的话，实际显示的物理像素就会是2或3，会显得边框很粗，这时可以：\n\n使用伪类，设置border: 1px scale(.5)\n使用伪类 + transform: scaleY(.5)\n\n4. link和@import区别\nlink是html标签，不仅可以引入css，还可以定义RSS，rel连接属性等；@import是css语法，只能导入样式表\nlink和页面同时加载，而@import会在页面加载完以后再下载资源\n兼容性有区别，@import在IE5+以后才能使用，而link不需要考虑兼容性\n\n5. display: none、visibility: hidden和opacity: 0的区别？效果都是隐藏元素\ndisplay: none 在文档布局中不在分配空间（节点），值变化会导致回流和重绘\nvisibility: hidden 保留渲染树中的节点，占用空间，会导致重绘，不能触发点击事件\nopacity: 0 透明度为0，元素依然存在，可以触发点击事件\n6. 哪些CSS属性是可以继承的外观相关的属性可以继承，如字体、文本相关属性布局相关属性不可继承\n7. 标准CSS盒子模型和低版本IE盒子模型区别box-sizing: context-box; 标准盒子模型：宽度&#x3D;内容的宽度（content）+ border + padding + marginbox-sizing: border-box; IE低版本盒子模型：宽度&#x3D;内容的宽度（content+ border + padding）+ margin\n8. 流式布局和响应式布局的区别流式布局：用非固定像素方式定义网页内容，也就是百分比布局。响应式布局：用媒体查询方式来指定某宽度区间内的网页布局。\n9. 宽度分离原则示例代码：\ndiv.demo &#123;\n  width: 200px;\n&#125;\n\n此时我们增加需求，需要20px的内边距，则代码需要修改如下\ndiv.demo &#123;\n  width: 160px;\n  padding: 20px;\n&#125;\n\n我们需要如代码所示增加20px内边距的同时，自己计算width的改变，但如果使用宽度分离原则，则代码如下\ndiv.father &#123;\n  width: 200px;\n&#125;\ndiv.son &#123;\n  padding: 20px;\n&#125;\n\n也就是在原本的元素只用来定义宽度，所有内容放置于一个子元素之中，子元素的padding、border、（某些情况下的margin）可以随时修改，利用流动性在父级内部自适应呈现，有利于代码的维护。\n10. 超越 !important 问题max-width会覆盖width，这种情况是超级覆盖，比!important权重更高min-width会超越max-width，这种情况发生在min-width的值比max-width的值更大的情况下，如下\n.demo &#123;\n  max-height: 100px !important;\n  min-height: 500px;\n&#125;\n\n此时，.demo元素的高度为500px。\n11. 使用content实现打点loading效果dot &#123;\n    display: inline-block; \n    height: 1em;\n    line-height: 1;\n    text-align: left;\n    vertical-align: -.25em;\n    overflow: hidden;\n&#125;\ndot::before &#123;\n    display: block;\n    content: &#39;...\\A..\\A.&#39;;\n    white-space: pre-wrap;\n    animation: dot 3s infinite step-start both;\n&#125;\n@keyframes dot &#123;\n    33% &#123; transform: translateY(-2em); &#125;\n    66% &#123; transform: translateY(-1em); &#125;\n&#125;","slug":"前端知识点之CSS汇总篇/index","date":"2023-06-26T16:00:00.000Z","categories_index":"知识点","tags_index":"CSS,面试题","author_index":"Life Experiencer"},{"id":"cd75f7c6287f064b0d8db8463d91e774","title":"前端知识点之HTML汇总篇","content":"1. src与href的区别src: 表示对资源的引用，它所指向的内容会被直接嵌入到当前标签所在的位置，例如图片、js脚本等。当浏览器解析到该元素时，会立刻停止其他资源的下载和处理，直到将该资源加载、编译、执行完毕，所以一般都会将js放在页面底部去处理。href: 表示超文本引用，它指向的是一些网络资源，建立和当前元素或文本标签的链接关系。当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理。通常用在a标签、link标签上。\n2. 语义化语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事儿。语义化的优点有：\n\n对机器友好，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，还支持读屏软件根据文章自动生成目录。\n对开发者友好，能增强代码可读性，使层次结构更加清晰，便于团队的开发与维护。\n\n&lt;header&gt;&lt;&#x2F;header&gt; &lt;!-- 头部 --&gt;\n&lt;section&gt;&lt;&#x2F;section&gt; &lt;!-- 区块 --&gt;\n&lt;nav&gt;&lt;&#x2F;nav&gt; &lt;!-- 导航栏 --&gt;\n&lt;main&gt;&lt;&#x2F;main&gt; &lt;!-- 主要区域 --&gt;\n&lt;aside&gt;&lt;&#x2F;aside&gt; &lt;!-- 侧边栏 --&gt;\n&lt;article&gt;&lt;&#x2F;article&gt; &lt;!-- 主要内容 --&gt;\n&lt;footer&gt;&lt;&#x2F;footer&gt; &lt;!-- 底部 --&gt;\n\n3. DOCTYPE(⽂档类型) 的作⽤DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。它不属于HTML标签，而是一条指令。浏览器渲染页面的两种模式（可以通过document.compatMode来获取）：CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。\n4. script标签中defer和async的区别在浏览器的默认解析中，解析到script标签时会同步处理后续文档，也就是等待该js文件加载、编译、执行结束才会继续处理后续文档。蓝色代表js脚本的网络加载时间，红色代表js脚本的执行时间，绿色代表html解析。\ndefer: 异步加载，最后处理async: 异步加载，同步执行\n\n\n\n\n\n\n\n\n\n默认情况适合主要通路的js文件，没有该文件无法继续渲染的情况defer适合最终展示模块，该文件依赖于各种前置文件、标签，需要等到前置内容解析完毕\n注意：两种都对内嵌脚本无效，因为内容已经在html里了，无需加载\n5. img的srcset属性和sizes属性的作用响应式页面中经常用到根据屏幕密度(即像素比，可以通过放大页面来调整)设置不同的图片，需要用到img标签的srcset属性，用于设置不同屏幕密度下，img自动加载不同图片\n&lt;img src&#x3D;&quot;image-128.png&quot; srcset&#x3D;&quot;image-256.png 2x, image-512.png 3x&quot; &#x2F;&gt;\n\n当屏幕正常像素比时，会显示image-128.png，当调整缩放&gt;200% &amp;&amp; &lt; 300%时，则会显示image-512.png\nsizes属性可以用媒体查询的方法指定图像宽度，但在这里的宽度我们通常使用w单位而非px，计算w的方式如下：在通常的pc机中像素比为1，则sizes计算值为375px的时候，img实际宽度为375×1&#x3D;375w，当在iphone 678中，像素比为2，则img实际宽度为375×2&#x3D;750w，iphone plus或iphone X的机型中像素比为3，则img实际宽度为375×3&#x3D;1125w\n&lt;img \n  src&#x3D;&quot;image1.png&quot;\n  sizes&#x3D;&quot;(max-width: 376px) 375px, (max-width: 769px) 768px, 1024px&quot;\n  srcset&#x3D;&quot;\n    image1.png 375w,\n    image2.png 768w,\n    image3.png 1024w\n    &quot;\n&gt;\n\n如此时，假如sizes计算宽度为375的情况下，在pc机中，显示的图片资源为image1，在iphone 678中显示image2，在iphone plus或iphone X中显示image3\n6. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素有：a b span img input select strong块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p\n空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：\n常见的有：br、hr、img、input、link、meta鲜见的有：area、base、col、colgroup、command、embed、keygen、param&gt;、source、track、wbr\n7. web work\n\n\n\n\n\n提示\nweb work（工作线程）是在HTML5中提出的概念，分成两种类型：专用线程(Dedicated Web Worker)和共享线程(Shared Web Worker)。专用线程只能被创建它的脚本所使用共享线程能够被不同的脚本使用\n\n用途：将一些耗时的数据处理操作从主线程中剥离，让主线程专注于页面渲染和交互。\n\n懒加载\n文本分析\n流媒体数据处理\ncanvas图形绘制\n图像处理\n……\n\n注：\n\n同源限制\n无法访问DOM节点\n运行在另一个上下文，无法使用Window对象\n运行时不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果使用该线程频繁与主线程交互的话，主线程由于需要处理交互逻辑，仍有可能使页面发生阻塞\n共享线程可以被多个浏览上下文调用，但所有这些浏览上下文必须同源（相同协议、主机和端口号）\n\n具体使用方式可以复制下面两个文件进行测试：\n文件1：主线程html文件\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        Worker 输出内容：&lt;span id&#x3D;&#39;app&#39;&gt;&lt;&#x2F;span&gt;\n        &lt;input type&#x3D;&#39;text&#39; title&#x3D;&#39;&#39; id&#x3D;&#39;msg&#39;&gt;\n        &lt;button onclick&#x3D;&#39;sendMessage()&#39;&gt;发送&lt;&#x2F;button&gt;\n        &lt;button onclick&#x3D;&#39;stopWorker()&#39;&gt;stop!&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  \n    &lt;script type&#x3D;&#39;text&#x2F;javascript&#39;&gt;\n        if (typeof(Worker) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;)\t&#x2F;&#x2F; 使用Worker前检查一下浏览器是否支持\n        document.writeln(&#39; Sorry! No Web Worker support.. &#39;)\n        else &#123;\n            window.w &#x3D; new Worker(&#39;.&#x2F;work.js&#39;, &#123;name: &#39;w&#39;&#125;)\n            window.w.onmessage &#x3D; ev &#x3D;&gt; &#123;\n            document.getElementById(&#39;app&#39;).innerHTML &#x3D; ev.data\n        &#125;\n        \n        window.w.onerror &#x3D; err &#x3D;&gt; &#123;\n            w.terminate()\n            console.log(error.filename, error.lineno, error.message) &#x2F;&#x2F; 发生错误的文件名、行号、错误内容\n        &#125;\n        \n        function sendMessage() &#123;\n            const msg &#x3D; document.getElementById(&#39;msg&#39;)\n            window.w.postMessage(msg.value)\n        &#125;\n        \n        function stopWorker() &#123;\n            window.w.terminate()\n        &#125;\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文件2：Work线程文件\nlet i &#x3D; 1\n\nfunction simpleCount() &#123;\n  i++\n  self.postMessage(i)\n  setTimeout(simpleCount, 1000)\n&#125;\n\nsimpleCount()\n\nself.onmessage &#x3D; ev &#x3D;&gt; &#123;\n  postMessage(ev.data + &#39;测试接收&#39;)\n&#125;\n\n参考：MDN - Web Workers 概念与用法阮一峰 - Web Worker 使用教程JavaScript 工作原理之七－Web Workers 分类及 5 个使用场景Web Worker在项目中的妙用怎么在 ES6+Webpack 下使用 Web Worker\n8. HTML5的离线储存怎么使用，它的工作原理是什么？离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n原理：HTML5的离线存储是基于一个新建的 manifest 文件，文件后缀名为 .appcache 的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; manifest&#x3D;&quot;demo.appcache&quot;&gt;\n&lt;&#x2F;html&gt;\n\n更多细节未作深入研究\n9. iframe 有那些优点和缺点？iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。\n优点：\n\n因其的加载是和主页面异步的，所以可以加载复杂耗时的内容如广告等\n可以实现跨子域通信\n使脚本可以并行下载\n\n缺点：\n\niframe 会阻塞主页面的onload事件\n无法被一些搜索引擎识别\n会产生很多页面，不容易管理\n\n10. title与h1 b与strong i与emtitle没有明确意义只是个标题，h1则是层次比较明确的标题\nstrong有语义而b没有，搜索引擎更侧重于strong\nem有语义而i没有\n11. label标签作用label用来定义表单控件的关系，当用户选择label标签，浏览器会帮助用户自动聚焦和该label标签所关联的表单控件\n使用方式：\n&lt;label for&#x3D;&quot;mobile&quot;&gt;Number:&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;mobile&quot;&#x2F;&gt;\n\n&lt;label&gt;Date:&lt;input type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;&#x2F;label&gt;\n\n12. SVG和Canvas区别SVG是基于XML描述的2D图形语言，这意味着其中的每个图形都是可用的，都可以为其添加JS事件处理器，每个图形都被视为对象，如果SVG的对象属性发生变化，浏览器会自动重现图形。特点：\n\n不依赖分辨率\n支持事件处理\n最适合带有大型渲染区域的应用程序（比如地图）\n复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）\n不适合游戏应用\n\nCanvas是画布，基于JavaScript对其进行绘制的2D图形，是逐像素进行渲染的，位置发生改变时，就会重新渲染。特点：\n\n依赖分辨率\n不支持事件处理\n较弱的文本渲染能力\n能以.png或.jpg格式保存渲染的图像结果\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n13. head元素作用用于定义文档的头部，是所有头部元素的容器。当中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。描述了文档各种属性和信息。\n其中可以包含base, link, meta, script, style, title，其中的title是唯一的必须的标签。\n14. 浏览器乱码的原因是什么？如何解决？原因：\n\n网页原编码是gbk编码，如果内容中的中文是utf-8编码的话，浏览器打开时就会乱码，反之也会出现乱码\n从数据库调用的数据是utf-8编码，也会造成此情况\n浏览器不能自动检测网页编码，造成乱码\n\n解决方案：\n\n使用软件编辑HTML网页内容，保证编码一致\n如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进行程序转码\n如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换\n\n15. 优雅降级和渐进增强的区别.transition&#123;\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;  \n&#125;\n.transition&#123; \n　　     transition: all .5s;\n　　  -o-transition: all .5s;\n  　-moz-transition: all .5s;\n -webkit-transition: all .5s;\n&#125;\n\n优雅降级是以复杂现状为基础，试图减少用户体验的供给。优雅降级观点认为应该针对最先进、最高级的浏览器来设计，而将那些过时、老旧的浏览器版本放置于开发周期的最后阶段，在这种观点下，旧版浏览器被视为仅能提供“简陋却无妨”的浏览体验，可以做些小的调整来适应某个浏览器的特性，但由于他并不是我们关注的重点，因此除了修复较大的功能错误以外，其他差异将被直接忽略。\n渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要，渐进增强的观点是应该关注内容本身，因为不论浏览器收集、展示、寻求还是操作内容，其共同点是都涉及到内容。\n16. HTML5 drag API\ndragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。\n\ndarg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。\n\ndragend：事件主体是被拖放元素，在整个拖放操作结束时触发。\n\ndragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。\n\ndragover：事件主体是目标元素，在被拖放在某元素内移动时触发。\n\ndragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。\n\ndrop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\n\n\n示例：\n&lt;style&gt;\n    #drop-area &#123;\n        width: 50px;\n        height: 50px;\n        background-color: yellow;\n    &#125;\n&lt;&#x2F;style&gt;\n\n&lt;div id&#x3D;&quot;drop-area&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;drag-el&quot; draggable&#x3D;&quot;true&quot;&gt;...&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    window.onload &#x3D; () &#x3D;&gt; &#123;\n        const dragEl &#x3D; document.querySelector(&#39;#drag-el&#39;)\n        const dropArea &#x3D; document.querySelector(&#39;#drop-area&#39;)\n\n        dragEl.addEventListener(&#39;dragstart&#39;, (event) &#x3D;&gt; &#123;\n            event.dataTransfer.setData(&#39;text&#x2F;plain&#39;, event.target.id);\n        &#125;)\n        dropArea.addEventListener(&#39;dragover&#39;, (event) &#x3D;&gt; &#123;\n            event.preventDefault();\n        &#125;)\n        dropArea.addEventListener(&#39;drop&#39;, (event) &#x3D;&gt; &#123;\n            const id &#x3D; event.dataTransfer.getData(&#39;text&#x2F;plain&#39;);\n            dropArea.appendChild(document.getElementById(id));\n        &#125;);\n    &#125;\n&lt;&#x2F;script&gt;","slug":"前端知识点之HTML汇总篇/index","date":"2023-06-18T16:00:00.000Z","categories_index":"知识点","tags_index":"面试题,HTML","author_index":"Life Experiencer"},{"id":"b945a3fa38137babb32ce78c9f125574","title":"Hexo搭建+配置GitHub Pages","content":"Hexo搭建+配置GitHub Pages1.0 搭建Hexo1.1 安装Node.js1.2 安装Git1.3 使用npm安装Hexo $ npm install -g hexo-cli\n&#x2F;&#x2F; hexo init [folder]\n $ hexo init Blog\n\n1.4 安装主题包$ npm install hexo-theme-aurora\n\n\n\n\n\n\n\n\n\n\n在 node_modules 目录下的hexo-theme-aurora 主题文件夹中复制 _config.yml 文件到根目录下，并重命名为 _config.aurora.yml\n\n\n\n\n\n\n\n\n\n\n\n修改根目录下的_config.yml配置项\n注：配置项的:后必须添加空格，否则会报错映射失败\ntheme: Aurora\n\n1.5 关闭评论\n\n\n\n\n\n\n\n\n全局搜索 ye.render=ie;\n注释这一句代码\n1.6 设置代码高亮\n\n\n\n\n\n\n\n\n修改根目录下的_config.yml配置项\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: false\n  line_number: true\n  tab_replace: &#39;&#39;\n\n1.7 关闭访客量\n\n\n\n\n\n\n\n\n修改根目录下_config.aurora配置项\nbusuanzi:\n  enable: false\n\n\n\n\n\n\n\n\n\n\n后续想要添加或重写算法可以访问[不蒜子](不蒜子 | 不如 (ibruce.info))\n2. 配置到GitHub Pages\n\n\n\n\n\n\n注意\ngit仓库名必须为[用户名].github.io\n\n下载hexo部署插件\n$ npm install hexo-deployer-git --save\n\n\n\n\n\n\n\n\n\n\n修改根目录下_config.yml配置项\nurl: https:&#x2F;&#x2F;meng160626.github.io&#x2F;\n\ndeploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;meng160626&#x2F;meng160626.github.io.git\n  branch: main\n\n此后可以通过https://meng160626.github.io/访问\n每次部署需要执行如下命令 (又称一键三连\n$ hexo clean\n$ hexo g\n$ hexo d\n\n3. 疑难问题3.1 VS Code控制台无法运行脚本\n\n\n\n\n\n\n\n\n当使用VS Code控制台输入命令hexo server报错在此系统上禁止运行脚本时\n打开Windows设置 -&gt; 搜索PowerShell -&gt; 选择允许 -&gt; 应用\n\n3.2 在hexo中展示静态页面在 source 文件夹下创建 html 文件夹将静态页面放入html文件夹\n\n\n\n\n\n\n\n\n\n修改根目录下_config.yml配置项\nskip_render:\n - &quot;html&#x2F;*&quot;\n\n\n\n\n\n\n\n\n\n修改根目录下_config.aurora配置项\nmenu:\n  About: false\n  Tags: false\n  Archives: false\n  projects:\n    name: &#39;代码库&#39;\n    i18n:\n      cn: &#39;代码库&#39;\n      en: &#39;repositories&#39;\n    children:\n      material:\n        name: &#39;素材库&#39;\n        i18n: \n          cn: &#39;素材库&#39;\n          en: &#39;material&#39;\n        path: &#39;https:&#x2F;&#x2F;meng160626.github.io&#x2F;charts&#x2F;&#39;\n      svg-tab:\n        name: &#39;svg-tab&#39;\n        i18n: \n          cn: &#39;svg-tab&#39;\n          en: &#39;svg-tab&#39;\n        path: &#39;https:&#x2F;&#x2F;meng160626.github.io&#x2F;html&#x2F;svg-tab.html&#39;\n","slug":"Hexo搭建+配置GitHub Pages/index","date":"2023-04-05T16:00:00.000Z","categories_index":"环境搭建及配置","tags_index":"Hexo","author_index":"Life Experiencer"},{"id":"b1ff9fa1698c1511850c33cadadfda26","title":"wangEditor修改高亮文字样式","content":"修改wangeditor中所使用的highlight.js的高亮颜色找到 node_modules -&gt; @wangeditor -&gt; editor -&gt; dist -&gt; css -&gt; style.css\n在其中搜索要修改的颜色值，直接修改即可\n","slug":"wangEditor修改高亮文字样式/index","date":"2023-02-09T16:00:00.000Z","categories_index":"工具类","tags_index":"wangEditor","author_index":"Life Experiencer"},{"id":"252d505e28324426d832f92b75665197","title":"回流和重绘","content":"浏览器渲染机制浏览器采用流式布局模型。通过把HTML解析成DOM CSS解析成CSSOM DOM和CSSOM合并成Render Tree渲染树。有了Render Tree就知道了所有节点的样式，再计算大小和位置，最后绘制在页面上。\n通常计算流式布局只需要一次，但table及其内部元素除外，他们需要通过多次计算，所以要避免使用table布局。、\n重绘由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline,visibility,color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。\n回流回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。\n\n\n\n\n\n\n\n注意\n回流必定重绘 重绘未必回流\n\n如何优化浏览器角度现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。主要包括以下属性或方法：\n\n\n\n\n\n\n\n\n\n1、offsetTop、offsetLeft、offsetWidth、offsetHeight2、scrollTop、scrollLeft、scrollWidth、scrollHeight3、clientTop、clientLeft、clientWidth、clientHeight4、width、height5、getComputedStyle()6、getBoundingClientRect()\n所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。\nCSS角度\n\n\n\n\n\n\n\n\n1、使用transform替代top2、使用visibility替换display: none，因为前者只会引起重绘，后者会引发回流（改变了布局3、避免使用table布局，可能很小的一个小改动会造成整个table的重新布局4、尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点5、避免设置多层内联样式，CSS选择符从右往左匹配查找，避免节点层级过多\nJS角度\n\n\n\n\n\n\n\n\n1、避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性2、避免频繁操作DOM，创建一个documentFragment(官方提供的虚拟DOM)，在它上面应用所有DOM操作，最后再把它添加到文档中3、避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来4、对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流\n","slug":"回流和重绘/index","date":"2023-01-03T16:00:00.000Z","categories_index":"效率优化","tags_index":"重绘,回流","author_index":"Life Experiencer"},{"id":"b39eb3771e2c27928893a4957cbefffa","title":"普通函数和箭头函数对比","content":"当创建者、调用者一致时\n!(() &#x3D;&gt; &#123;\n    console.log(this);      &#x2F;&#x2F; Window\n&#125;)();\n\n!(function() &#123;\n    console.log(this);      &#x2F;&#x2F; Window\n&#125;)();\n\n进行对照实验\nconst obj &#x3D; &#123;\n    func: function() &#123;\n        console.log(this);\n    &#125;,\n    lam: () &#x3D;&gt; &#123;\n        console.log(this);\n    &#125;\n&#125;;\n\nconst a &#x3D; &#123;\n    name: &#39;a&#39;\n&#125;;\n\nobj.func.call(a);   &#x2F;&#x2F; a\nobj.lam.call(a);    &#x2F;&#x2F; Window\nobj.func();         &#x2F;&#x2F; obj\nobj.lam();          &#x2F;&#x2F; Window\n\nconst obj &#x3D; &#123;\n    func: function() &#123;\n        return function() &#123;\n            console.log(this);\n        &#125;\n    &#125;,\n    lam: function() &#123;\n        return () &#x3D;&gt; &#123;\n            console.log(this);\n        &#125;\n    &#125;\n&#125;;\n\nobj.func()();       &#x2F;&#x2F; Window\nobj.lam()();        &#x2F;&#x2F; obj\n\n总结\n\n\n\n\n\n\n\n\n箭头函数在创建时就已经绑定了this，即指向其父级外层的this，而不是使用时所在的作用域指向的对象(可以快速的识别箭头函数的this，即将其所在的大括号去掉，或理解为父级所在的this)\n","slug":"箭头函数/index","date":"2022-11-02T16:00:00.000Z","categories_index":"知识点","tags_index":"箭头函数","author_index":"Life Experiencer"},{"id":"55764d82013bf7d28ae08f515ae0da0c","title":"vite配置https","content":"1.全局安装mkcert$ npm i mkcert -g\n\n2.在任意目录，打开终端输入指令，生成ca证书$ mkcert create-ca\n\n3.再根据ca证书生成cert证书$ mkcert create-cert localhost 127.0.0.1\n\n双击ca.crt导入证书\n点击 安装证书—&gt;勾选本地计算机—&gt;选择将所有证书都放入下列存储中的受信任的根证书颁发机构—&gt;确定导入成功将cert.crt和cert.key放到项目的src&#x2F;assets&#x2F;ssl目录下\n4.配置证书export default defineConfig(&#123;\n  plugins: [vue()],\n  server: &#123;\n    host: &#39;0.0.0.0&#39;,\n    https: &#123;\n      cert: fs.readFileSync(path.join(__dirname, &#39;src&#x2F;assets&#x2F;ssl&#x2F;cert.crt&#39;)),\n      key: fs.readFileSync(path.join(__dirname, &#39;src&#x2F;assets&#x2F;ssl&#x2F;cert.key&#39;))\n    &#125;\n  &#125;,\n&#125;)","slug":"Vite配置https证书/index","date":"2022-10-21T16:00:00.000Z","categories_index":"环境搭建及配置","tags_index":"vite,https","author_index":"Life Experiencer"},{"id":"22dc96c39bfd9211e7d5443bdb3c36d8","title":"小程序嵌入Echarts","content":"1. 构建组件嵌入Echarts新建一个文件夹ec-canvas，用于专门放置echarts相关文件，并创建同名的组件\n前往echarts官网制定自定义主题（因微信小程序大小限制，选择项目中需要用到的即可，尽量减少文件大小），之后将打包好的echarts.js文件放到上述创建好的目录中，然后编写如下代码：\nec-canvas.wxml文件\n&lt;!-- 新的--&gt;\n&lt;canvas\n    wx:if&#x3D;&quot;&#123;&#123;isUseNewCanvas&#125;&#125;&quot;\n\ttype&#x3D;&quot;2d&quot;s\n    class&#x3D;&quot;ec-canvas&quot;\n    canvas-id&#x3D;&quot;&#123;&#123; canvasId &#125;&#125;&quot;\n    bindinit&#x3D;&quot;init&quot;\n    bindtouchstart&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchStart&#39; &#125;&#125;&quot;\n    bindtouchmove&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchMove&#39; &#125;&#125;&quot;\n    bindtouchend&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchEnd&#39; &#125;&#125;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n&lt;!-- 旧的 --&gt;\n&lt;canvas\n    wx:else\n    class&#x3D;&quot;ec-canvas&quot;\n    canvas-id&#x3D;&quot;&#123;&#123; canvasId &#125;&#125;&quot;\n    bindinit&#x3D;&quot;init&quot;\n    bindtouchstart&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchStart&#39; &#125;&#125;&quot;\n    bindtouchmove&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchMove&#39; &#125;&#125;&quot;\n    bindtouchend&#x3D;&quot;&#123;&#123; ec.disableTouch ? &#39;&#39; : &#39;touchEnd&#39; &#125;&#125;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n\n\n\n\n\n\n\n提示\n至于为什么用isUseNewCanvas变量控制，可以参考文章\n\nec-canvas.js文件\nimport WxCanvas from &#39;.&#x2F;wx-canvas&#39;;\nimport * as echarts from &#39;.&#x2F;echarts&#39;;\n\nlet ctx;\n\nfunction compareVersion(v1, v2) &#123;\n  v1 &#x3D; v1.split(&#39;.&#39;)\n  v2 &#x3D; v2.split(&#39;.&#39;)\n  const len &#x3D; Math.max(v1.length, v2.length)\n\n  while (v1.length &lt; len) &#123;\n    v1.push(&#39;0&#39;)\n  &#125;\n  while (v2.length &lt; len) &#123;\n    v2.push(&#39;0&#39;)\n  &#125;\n\n  for (let i &#x3D; 0; i &lt; len; i++) &#123;\n    const num1 &#x3D; parseInt(v1[i])\n    const num2 &#x3D; parseInt(v2[i])\n\n    if (num1 &gt; num2) &#123;\n      return 1\n    &#125; else if (num1 &lt; num2) &#123;\n      return -1\n    &#125;\n  &#125;\n  return 0\n&#125;\n\nComponent(&#123;\n  properties: &#123;\n    canvasId: &#123;\n      type: String,\n      value: &#39;ec-canvas&#39;\n    &#125;,\n\n    ec: &#123;\n      type: Object\n    &#125;,\n\n    forceUseOldCanvas: &#123;\n      type: Boolean,\n      value: false\n    &#125;\n  &#125;,\n\n  data: &#123;\n    isUseNewCanvas: true\n  &#125;,\n\n  ready: function () &#123;\n    &#x2F;&#x2F; 禁用渐进式，因为drawImage不支持DOM作为参数\n    &#x2F;&#x2F; 查看 https:&#x2F;&#x2F;developers.weixin.qq.com&#x2F;miniprogram&#x2F;dev&#x2F;api&#x2F;canvas&#x2F;CanvasContext.drawImage.html\n    echarts.registerPreprocessor(option &#x3D;&gt; &#123;\n      if (option &amp;&amp; option.series) &#123;\n        if (option.series.length &gt; 0) &#123;\n          option.series.forEach(series &#x3D;&gt; &#123;\n            series.progressive &#x3D; 0;\n          &#125;);\n        &#125;\n        else if (typeof option.series &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          option.series.progressive &#x3D; 0;\n        &#125;\n      &#125;\n    &#125;);\n\n    if (!this.data.ec) &#123;\n      console.warn(&#39;组件需绑定 ec 变量，例：&lt;ec-canvas id&#x3D;&quot;mychart-dom-bar&quot; &#39;\n        + &#39;canvas-id&#x3D;&quot;mychart-bar&quot; ec&#x3D;&quot;&#123;&#123; ec &#125;&#125;&quot;&gt;&lt;&#x2F;ec-canvas&gt;&#39;);\n      return;\n    &#125;\n\n    if (!this.data.ec.lazyLoad) &#123;\n      this.init();\n    &#125;\n  &#125;,\n\n  methods: &#123;\n    init: function (callback) &#123;\n      const version &#x3D; wx.getSystemInfoSync().SDKVersion\n\n      const canUseNewCanvas &#x3D; compareVersion(version, &#39;2.9.0&#39;) &gt;&#x3D; 0;\n      const forceUseOldCanvas &#x3D; this.data.forceUseOldCanvas;\n      const isUseNewCanvas &#x3D; canUseNewCanvas &amp;&amp; !forceUseOldCanvas;\n      this.setData(&#123; isUseNewCanvas &#125;);\n\n      if (forceUseOldCanvas &amp;&amp; canUseNewCanvas) &#123;\n        console.warn(&#39;开发者强制使用旧canvas,建议关闭&#39;);\n      &#125;\n\n      if (isUseNewCanvas) &#123;\n        &#x2F;&#x2F; console.log(&#39;微信基础库版本大于2.9.0，开始使用&lt;canvas type&#x3D;&quot;2d&quot;&#x2F;&gt;&#39;);\n        &#x2F;&#x2F; 2.9.0 可以使用 &lt;canvas type&#x3D;&quot;2d&quot;&gt;&lt;&#x2F;canvas&gt;\n        this.initByNewWay(callback);\n      &#125; else &#123;\n        const isValid &#x3D; compareVersion(version, &#39;1.9.91&#39;) &gt;&#x3D; 0\n        if (!isValid) &#123;\n          console.error(&#39;微信基础库版本过低，需大于等于 1.9.91。&#39;\n            + &#39;参见：https:&#x2F;&#x2F;github.com&#x2F;ecomfe&#x2F;echarts-for-weixin&#39;\n            + &#39;#%E5%BE%AE%E4%BF%A1%E7%89%88%E6%9C%AC%E8%A6%81%E6%B1%82&#39;);\n          return;\n        &#125; else &#123;\n          console.warn(&#39;建议将微信基础库调整大于等于2.9.0版本。升级后绘图将有更好性能&#39;);\n          this.initByOldWay(callback);\n        &#125;\n      &#125;\n    &#125;,\n\n    initByOldWay(callback) &#123;\n      &#x2F;&#x2F; 1.9.91 &lt;&#x3D; version &lt; 2.9.0：原来的方式初始化\n      ctx &#x3D; wx.createCanvasContext(this.data.canvasId, this);\n      const canvas &#x3D; new WxCanvas(ctx, this.data.canvasId, false);\n\n      echarts.setCanvasCreator(() &#x3D;&gt; &#123;\n        return canvas;\n      &#125;);\n      &#x2F;&#x2F; const canvasDpr &#x3D; wx.getSystemInfoSync().pixelRatio &#x2F;&#x2F; 微信旧的canvas不能传入dpr\n      const canvasDpr &#x3D; 1\n      var query &#x3D; wx.createSelectorQuery().in(this);\n      query.select(&#39;.ec-canvas&#39;).boundingClientRect(res &#x3D;&gt; &#123;\n        if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n          this.chart &#x3D; callback(canvas, res.width, res.height, canvasDpr);\n        &#125;\n        else if (this.data.ec &amp;&amp; typeof this.data.ec.onInit &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n          this.chart &#x3D; this.data.ec.onInit(canvas, res.width, res.height, canvasDpr);\n        &#125;\n        else &#123;\n          this.triggerEvent(&#39;init&#39;, &#123;\n            canvas: canvas,\n            width: res.width,\n            height: res.height,\n            canvasDpr: canvasDpr &#x2F;&#x2F; 增加了dpr，可方便外面echarts.init\n          &#125;);\n        &#125;\n      &#125;).exec();\n    &#125;,\n\n    initByNewWay(callback) &#123;\n      &#x2F;&#x2F; version &gt;&#x3D; 2.9.0：使用新的方式初始化\n      const query &#x3D; wx.createSelectorQuery().in(this)\n      query\n        .select(&#39;.ec-canvas&#39;)\n        .fields(&#123; node: true, size: true &#125;)\n        .exec(res &#x3D;&gt; &#123;\n          const canvasNode &#x3D; res[0].node\n          this.canvasNode &#x3D; canvasNode\n\n          const canvasDpr &#x3D; wx.getSystemInfoSync().pixelRatio\n          const canvasWidth &#x3D; res[0].width\n          const canvasHeight &#x3D; res[0].height\n\n          const ctx &#x3D; canvasNode.getContext(&#39;2d&#39;)\n\n          const canvas &#x3D; new WxCanvas(ctx, this.data.canvasId, true, canvasNode)\n          echarts.setCanvasCreator(() &#x3D;&gt; &#123;\n            return canvas\n          &#125;)\n\n          if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n            this.chart &#x3D; callback(canvas, canvasWidth, canvasHeight, canvasDpr)\n          &#125; else if (this.data.ec &amp;&amp; typeof this.data.ec.onInit &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n            this.chart &#x3D; this.data.ec.onInit(canvas, canvasWidth, canvasHeight, canvasDpr)\n          &#125; else &#123;\n            this.triggerEvent(&#39;init&#39;, &#123;\n              canvas: canvas,\n              width: canvasWidth,\n              height: canvasHeight,\n              dpr: canvasDpr\n            &#125;)\n          &#125;\n        &#125;)\n    &#125;,\n    canvasToTempFilePath(opt) &#123;\n      if (this.data.isUseNewCanvas) &#123;\n        &#x2F;&#x2F; 新版\n        const query &#x3D; wx.createSelectorQuery().in(this)\n        query\n          .select(&#39;.ec-canvas&#39;)\n          .fields(&#123; node: true, size: true &#125;)\n          .exec(res &#x3D;&gt; &#123;\n            const canvasNode &#x3D; res[0].node\n            opt.canvas &#x3D; canvasNode\n            wx.canvasToTempFilePath(opt)\n          &#125;)\n      &#125; else &#123;\n        &#x2F;&#x2F; 旧的\n        if (!opt.canvasId) &#123;\n          opt.canvasId &#x3D; this.data.canvasId;\n        &#125;\n        ctx.draw(true, () &#x3D;&gt; &#123;\n          wx.canvasToTempFilePath(opt, this);\n        &#125;);\n      &#125;\n    &#125;,\n\n    touchStart(e) &#123;\n      if (this.chart &amp;&amp; e.touches.length &gt; 0) &#123;\n        var touch &#x3D; e.touches[0];\n        var handler &#x3D; this.chart.getZr().handler;\n        handler.dispatch(&#39;mousedown&#39;, &#123;\n          zrX: touch.x,\n          zrY: touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n        handler.dispatch(&#39;mousemove&#39;, &#123;\n          zrX: touch.x,\n          zrY: touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n        handler.processGesture(wrapTouch(e), &#39;start&#39;);\n      &#125;\n    &#125;,\n\n    touchMove(e) &#123;\n      if (this.chart &amp;&amp; e.touches.length &gt; 0) &#123;\n        var touch &#x3D; e.touches[0];\n        var handler &#x3D; this.chart.getZr().handler;\n        handler.dispatch(&#39;mousemove&#39;, &#123;\n          zrX: touch.x,\n          zrY: touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n        handler.processGesture(wrapTouch(e), &#39;change&#39;);\n      &#125;\n    &#125;,\n\n    touchEnd(e) &#123;\n      if (this.chart) &#123;\n        const touch &#x3D; e.changedTouches ? e.changedTouches[0] : &#123;&#125;;\n        var handler &#x3D; this.chart.getZr().handler;\n        handler.dispatch(&#39;mouseup&#39;, &#123;\n          zrX: touch.x,\n          zrY: touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n        handler.dispatch(&#39;click&#39;, &#123;\n          zrX: touch.x,\n          zrY: touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n        handler.processGesture(wrapTouch(e), &#39;end&#39;);\n      &#125;\n    &#125;\n  &#125;\n&#125;);\n\nfunction wrapTouch(event) &#123;\n  for (let i &#x3D; 0; i &lt; event.touches.length; ++i) &#123;\n    const touch &#x3D; event.touches[i];\n    touch.offsetX &#x3D; touch.x;\n    touch.offsetY &#x3D; touch.y;\n  &#125;\n  return event;\n&#125;\n\nec-canvas.json文件\n&#123;\n  &quot;component&quot;: true,\n  &quot;usingComponents&quot;: &#123;&#125;\n&#125;\n\nec-canvas.wxss文件\n.ec-canvas &#123;\n  width: 100%;\n  height: 100%;\n&#125;\n\n创建wx-canvas.js文件\nexport default class WxCanvas &#123;\n  constructor(ctx, canvasId, isNew, canvasNode) &#123;\n    this.ctx &#x3D; ctx;\n    this.canvasId &#x3D; canvasId;\n    this.chart &#x3D; null;\n    this.isNew &#x3D; isNew\n    if (isNew) &#123;\n      this.canvasNode &#x3D; canvasNode;\n    &#125;\n    else &#123;\n      this._initStyle(ctx);\n    &#125;\n\n    &#x2F;&#x2F; this._initCanvas(zrender, ctx);\n\n    this._initEvent();\n  &#125;\n\n  getContext(contextType) &#123;\n    if (contextType &#x3D;&#x3D;&#x3D; &#39;2d&#39;) &#123;\n      return this.ctx;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; canvasToTempFilePath(opt) &#123;\n  &#x2F;&#x2F;   if (!opt.canvasId) &#123;\n  &#x2F;&#x2F;     opt.canvasId &#x3D; this.canvasId;\n  &#x2F;&#x2F;   &#125;\n  &#x2F;&#x2F;   return wx.canvasToTempFilePath(opt, this);\n  &#x2F;&#x2F; &#125;\n\n  setChart(chart) &#123;\n    this.chart &#x3D; chart;\n  &#125;\n\n  addEventListener() &#123;\n    &#x2F;&#x2F; noop\n  &#125;\n\n  attachEvent() &#123;\n    &#x2F;&#x2F; noop\n  &#125;\n\n  detachEvent() &#123;\n    &#x2F;&#x2F; noop\n  &#125;\n\n  _initCanvas(zrender, ctx) &#123;\n    zrender.util.getContext &#x3D; function () &#123;\n      return ctx;\n    &#125;;\n\n    zrender.util.$override(&#39;measureText&#39;, function (text, font) &#123;\n      ctx.font &#x3D; font || &#39;12px sans-serif&#39;;\n      return ctx.measureText(text);\n    &#125;);\n  &#125;\n\n  _initStyle(ctx) &#123;\n    ctx.createRadialGradient &#x3D; () &#x3D;&gt; &#123;\n      return ctx.createCircularGradient(arguments);\n    &#125;;\n  &#125;\n\n  _initEvent() &#123;\n    this.event &#x3D; &#123;&#125;;\n    const eventNames &#x3D; [&#123;\n      wxName: &#39;touchStart&#39;,\n      ecName: &#39;mousedown&#39;\n    &#125;, &#123;\n      wxName: &#39;touchMove&#39;,\n      ecName: &#39;mousemove&#39;\n    &#125;, &#123;\n      wxName: &#39;touchEnd&#39;,\n      ecName: &#39;mouseup&#39;\n    &#125;, &#123;\n      wxName: &#39;touchEnd&#39;,\n      ecName: &#39;click&#39;\n    &#125;];\n    eventNames.forEach(name &#x3D;&gt; &#123;\n      this.event[name.wxName] &#x3D; e &#x3D;&gt; &#123;\n        const touch &#x3D; e.touches[0];\n        this.chart.getZr().handler.dispatch(name.ecName, &#123;\n          zrX: name.wxName &#x3D;&#x3D;&#x3D; &#39;tap&#39; ? touch.clientX : touch.x,\n          zrY: name.wxName &#x3D;&#x3D;&#x3D; &#39;tap&#39; ? touch.clientY : touch.y,\n          preventDefault: () &#x3D;&gt; &#123;&#125;,\n          stopImmediatePropagation: () &#x3D;&gt; &#123;&#125;,\n          stopPropagation: () &#x3D;&gt; &#123;&#125;\n        &#125;);\n      &#125;;\n    &#125;);\n  &#125;\n\n  set width(w) &#123;\n    if (this.canvasNode) this.canvasNode.width &#x3D; w\n  &#125;\n  set height(h) &#123;\n    if (this.canvasNode) this.canvasNode.height &#x3D; h\n  &#125;\n\n  get width() &#123;\n    if (this.canvasNode)\n      return this.canvasNode.width\n    return 0\n  &#125;\n  get height() &#123;\n    if (this.canvasNode)\n      return this.canvasNode.height\n    return 0\n  &#125;\n&#125;\n以上代码均来自： echarts-for-weixin\n2.使用组件这里用this._chart的方式记录echarts实例，用于后续动态刷新\n&lt;ec-canvas\n    id&#x3D;&quot;line&quot;\n    type&#x3D;&quot;2d&quot;\n    canvas-id&#x3D;&quot;line&quot;\n    ec&#x3D;&quot;&#123;&#123;lineEC&#125;&#125;&quot;\n&gt;&lt;&#x2F;ec-canvas&gt;\nimport * as echarts from &#39;..&#x2F;..&#x2F;..&#x2F;ec-canvas&#x2F;echarts&#39;;\n\nPage(&#123;\n    data: &#123;\n        lineEC:&#123;\n          lazyLoad: true\n        &#125;,\n    &#125;,\n    &#x2F;&#x2F;绘制折线图\n    drawLine(dataList) &#123;\n        let xAxis &#x3D; [], series &#x3D; [];\n        const _dataList &#x3D; dataList.map((item,idx) &#x3D;&gt; &#123;\n            if(this.data.legendList.length &#x3D;&#x3D;&#x3D; 0) &#123;\n                item.color &#x3D; this.data._baseColor[idx];\n            &#125;else &#123;\n                item.color &#x3D; this.data.legendList.find(item2 &#x3D;&gt; item2.name &#x3D;&#x3D;&#x3D; item.name).color;\n            &#125;\n\n            if(item.active &#x3D;&#x3D;&#x3D; undefined) &#123;\n                item.active &#x3D; true;   &#x2F;&#x2F;是否激活\n            &#125;\n            xAxis &#x3D; item.data.map(item2 &#x3D;&gt; formatterDate(new Date(item2.time), &#39;HH:mm:ss&#39;));\n            series.push(&#123;\n                ...item,\n                type: &#39;line&#39;,\n                lineStyle: &#123;\n                    color: item.color\n                &#125;,\n                symbol: &#39;none&#39;,\n                data: item.data.map(item2 &#x3D;&gt; item2.value)\n            &#125;);\n            return item;\n        &#125;);\n        if(this.data.legendList.length &#x3D;&#x3D;&#x3D; 0) &#123;\n            this.setData(&#123;\n                legendList: _dataList\n            &#125;);\n        &#125;\n\n        this.selectComponent(&quot;#line&quot;).init((canvas, width, height, dpr) &#x3D;&gt; &#123;\n            let chart &#x3D; this._chart;\n            if(!this._chart) &#123;\n                chart &#x3D; echarts.init(canvas, null, &#123;\n                    width: width,\n                    height: height,\n                    devicePixelRatio: dpr\n                &#125;);\n                this._chart &#x3D; chart;\n            &#125;\n            canvas.setChart(chart);\n            chart.setOption(&#123;\n                tooltip: &#123;\n                    trigger: &#39;axis&#39;,\n                    formatter: function(params) &#123;\n                        let str &#x3D; &#96;$&#123;dataList[0].data[params[0].dataIndex].time&#125;\\n&#96;;\n                        params.forEach((item, idx) &#x3D;&gt; &#123;\n                            str +&#x3D; &#96;$&#123;item.marker&#125; $&#123;item.seriesName&#125;：$&#123;item.value&#125;$&#123;dataList[item.seriesIndex].unit&#125;&#96;;\n                            if(idx &lt; params.length - 1) str +&#x3D; &#39;\\n&#39;;\n                        &#125;);\n                        return str;\n                    &#125;,\n                    position: function (point, params, dom, rect, size) &#123;\n                        var x &#x3D; 0; &#x2F;&#x2F; x坐标位置\n                        var y &#x3D; 0; &#x2F;&#x2F; y坐标位置\n\n                        &#x2F;&#x2F; 当前鼠标位置\n                        var pointX &#x3D; point[0];\n                        var pointY &#x3D; point[1];\n\n                        &#x2F;&#x2F; 外层div大小\n                        var viewWidth &#x3D; size.viewSize[0];\n                        var viewHeight &#x3D; size.viewSize[1];\n\n                        &#x2F;&#x2F; 提示框大小\n                        var boxWidth &#x3D; size.contentSize[0];\n                        var boxHeight &#x3D; size.contentSize[1];\n                        if(pointX &lt; viewWidth &#x2F; 2) &#123;\n                            x &#x3D; pointX + 5;\n                        &#125;else &#123;\n                            x &#x3D; pointX - boxWidth - 5;\n                        &#125;\n\n                        &#x2F;&#x2F; boxHeight &gt; pointY 说明鼠标上边放不下提示框\n                        if (boxHeight &gt; pointY) &#123;\n                            y &#x3D; 5;\n                        &#125; else &#123; &#x2F;&#x2F; 上边放得下\n                            y &#x3D; pointY - boxHeight;\n                        &#125;\n                        return [x, y];\n                    &#125;\n                &#125;,\n                grid: &#123;\n                    top: &#39;10%&#39;,\n                    left: &#39;3%&#39;,\n                    right: &#39;4%&#39;,\n                    bottom: &#39;50%&#39;,\n                    containLabel: true\n                &#125;,\n                xAxis: &#123;\n                    type: &#39;category&#39;,\n                    boundaryGap: false,\n                    data: xAxis\n                &#125;,\n                yAxis: &#123;\n                    type: &#39;value&#39;\n                &#125;,\n                series\n            &#125;,true);\n            return chart;\n        &#125;);\n    &#125;\n&#125;);\n&#123;\n  ...\n  &quot;usingComponents&quot;: &#123;\n    &quot;ec-canvas&quot;: &quot;..&#x2F;..&#x2F;..&#x2F;ec-canvas&#x2F;ec-canvas&quot;\n  &#125;\n&#125;\n\n3.接入社区插件 实例为水球图将对应echarts版本的插件文件放入到文件夹中，例如echarts-liquidfill.js\n在js中引入对应插件即可使用\nimport * as liquidFill from &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ec-canvas&#x2F;echarts-liquidfill&#39;;\nimport * as echarts from &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ec-canvas&#x2F;echarts&#39;;\n\n&#x2F;**\n  * 项目右洞图表绘制\n  *&#x2F;\ndrawJcChart3(data) &#123;\n    wx.nextTick(() &#x3D;&gt; &#123;\n        this.selectComponent(&quot;#jc-chart3&quot;).init((canvas, width, height, dpr) &#x3D;&gt; &#123;\n            let chart &#x3D; echarts.init(canvas, null, &#123;\n                width: width,\n                height: height,\n                devicePixelRatio: dpr &#x2F;&#x2F; new\n            &#125;);\n            canvas.setChart(chart);\n            chart.setOption(this.getJcChartOptions(data, &quot;#4DF59B&quot;, &#39;#1DCDA5&#39;, &#39;#94fce4&#39;, &#39;#043526&#39;));\n            return chart;\n        &#125;);\n    &#125;);\n&#125;,\n&#x2F;**\n  * 获取水球图表配置\n  *&#x2F;\ngetJcChartOptions: function (data, color1, color2, color3, color4) &#123;\n    return &#123;\n        series: [\n            &#123;\n                &#x2F;&#x2F; value: 50, &#x2F;&#x2F;  内容 配合formatter\n                type: &#39;liquidFill&#39;,\n                radius: &#39;95%&#39;, &#x2F;&#x2F; 控制中间圆球的尺寸（此处可以理解为距离外圈圆的距离控制）\n                center: [&#39;50%&#39;, &#39;50%&#39;],\n                data: [\n                   &#123;\n                        value: data,\n                        itemStyle: &#123;\n                            shadowBlur: 10\n                        &#125;\n                    &#125;,\n                    &#123;\n                        value: data - 0.03,\n                        direction: &#39;left&#39;, &#x2F;&#x2F;波浪方向\n                        itemStyle: &#123;\n                            shadowBlur: 10\n                        &#125;\n                    &#125;,\n                ], &#x2F;&#x2F; data个数代表波浪数\n                backgroundStyle: &#123;\n                    borderWidth: 0,\n                    color: color3, &#x2F;&#x2F; 球体本景色\n                &#125;,\n                amplitude: &#39;6  %&#39;, &#x2F;&#x2F;波浪的振幅\n                color: [&#123;\n                    type: &#39;linear&#39;,\n                    x: 0,\n                    y: 0,\n                    x2: 0,\n                    y2: 1,\n                    colorStops: [&#123;\n                        offset: 1,\n                        color: color1,\n                    &#125;,\n                    &#123;\n                        offset: 0,\n                        color: color2,\n                    &#125;],\n                    globalCoord: false,\n                &#125;,],\n                label: &#123;\n                    normal: &#123;\n                        formatter: Math.round(data * 100 * 100) &#x2F; 100 + &#39;&#123;d|%&#125;&#39;,\n                        rich: &#123;\n                            d: &#123;\n                                fontSize: 18,\n                            &#125;,\n                        &#125;,\n                        textStyle: &#123;\n                            fontSize: 18,\n                            color: color4,\n                        &#125;,\n                    &#125;,\n                &#125;,\n                outline: &#123;\n                    show: false,\n                &#125;, \n            &#125;\n        ]\n    &#125;;\n&#125;,","slug":"小程序嵌入Echarts/index","date":"2022-10-07T16:00:00.000Z","categories_index":"小程序","tags_index":"小程序,Echarts,组件引入","author_index":"Life Experiencer"},{"id":"d2b1c86d84778284c9a48f05cbcb4fb9","title":"uni-app开发小程序 bug记录","content":"使用uView组件u-datetime-picker组件渲染失效\n\n\n\n\n\n\n\n\n\n使用该组件时，如果以任何方式配置cancel事件，会导致组件渲染失败需要如下添加两条属性，并且值不能为官方默认值，否则依旧会渲染失败\n\n无法穿透至组件内部修改样式\n\n\n\n\n\n\n\n\n需要在methods同级位置添加代码\noptions: &#123; styleIsolation: &#39;shared&#39; &#125;\n\n\n字体文件在工具中报错\n官方文档链接\n选择器*不能使用\n\n\n\n\n\n\n\n\nuni-app不支持*选择器\nucharts使用时绘制层级问题\n\n\n\n\n\n\n\n\n必须添加:canvas2d=&quot;true&quot;属性\n\n","slug":"uni-app开发小程序-bug记录/index","date":"2022-08-22T16:00:00.000Z","categories_index":"bug","tags_index":"bug,uni-app","author_index":"Life Experiencer"},{"id":"0e3018629513531f8d065044c5f51d64","title":"搭建Express框架","content":"Create ProjectExpress 中文网\nStart Serve$ npm start\n\n$ $env:DEBUG&#x3D;&#39;myapp:*&#39;; npm start\n\nChange View Engine To Html$ npm install ejs --save\n\napp.js\nvar ejs &#x3D; require(&#39;ejs&#39;);\n\n&#x2F;&#x2F; app.set(&#39;view engine&#39;, &#39;jade&#39;);\napp.engine(&#39;.html&#39;, ejs.__express) &#x2F;&#x2F; 设置视图引擎后缀，为.html\napp.set(&#39;view engine&#39;, &#39;html&#39;);     &#x2F;&#x2F; 设置视图引擎为html\n\n\n\n\n\n\n\n\n\n\n删除.jade文件 新建.html文件\nHot Update$ npm install -g node-dev\n或\n$ npm install node-dev -D\n\npackage.json\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;node-dev .&#x2F;bin&#x2F;www&quot;\n  &#125;\n&#125;\n\n$ npm run dev&#96;","slug":"Express搭建/index","date":"2022-08-02T16:00:00.000Z","categories_index":"环境搭建及配置","tags_index":"环境搭建及配置,node.js,Express","author_index":"Life Experiencer"},{"id":"859c08d30a5499f1a412de01ef363b3c","title":"使用VS Code开发uni-app","content":"Project info\n\n\n\n\n\n\n\n\n编辑器：VS Code框架：uni-app\nProject create\n\n\n\n\n\n\n\n\n使用npm搭配vue-cli\n$ vue create -p dcloudio&#x2F;uni-preset-vue &#39;project name&#39;\n\nProject setup在package.json中添加配置\n&quot;scripts&quot;: &#123;\n    &quot;devDependencies&quot;: &#123;\n        &quot;sass&quot;: &quot;^1.49.8&quot;,          &#x2F;&#x2F; 如使用其他版本可能因为版本过高导致启动服务失败\n        &quot;sass-loader&quot;: &quot;^8.0.2&quot;,    &#x2F;&#x2F; 如使用其他版本可能因为版本过高导致启动服务失败\n    &#125;\n&#125;\n\n$ npm install\n\nuView-ui推荐通过HBuilderX引入插件方式添加\n在package.json中添加配置\n&quot;scripts&quot;: &#123;\n  &quot;serve:wx&quot;: &quot;npm run dev:mp-weixin&quot;,\n  &quot;dev:mp-weixin&quot;: &quot;cross-env NODE_ENV&#x3D;development UNI_PLATFORM&#x3D;mp-weixin vue-cli-service uni-build --watch&quot;,\n&#125;\n\n\n\nProject run$ npm run serve:wx\n\n在微信开发者工具导入项目:路径为dist\\dev\\mp-weixin即可热更新\nVS Code 开发插件uni-app-schemas\n\n\n\n\n\n\n\n\n校验 uni-app 中的 androidPrivacy.json、pages.json 和 manifest.json 格式\nuni-app-snippets\n\n\n\n\n\n\n\n\nuni-app 基本能力代码片段\nuni-create-view\n\n\n\n\n\n\n\n\n快速创建uniapp视图与组件可以创建分包组件\n","slug":"使用VSCode开发uni-app/index","date":"2022-08-02T16:00:00.000Z","categories_index":"环境搭建及配置","tags_index":"环境搭建及配置,uni-app,VS Code","author_index":"Life Experiencer"},{"id":"c6ed01f79789c67a9afc63759dd9592c","title":"wx小程序 bug记录","content":"\n\n\n\n\n\n\n注意！\n遇到所有问题，先在真机跑一下，说不定好了\n\n微信小程序webview两次返回问题1.下载SDK文件概述 | 微信开放文档 (qq.com\n2.在H5页面中引入SDK文件加入如下逻辑即可\nmounted() &#123;\n    history.pushState(&#123;page: 1&#125;, null, window.location.href);\n    &#x2F;&#x2F;然后监听popstate事件\n    window.addEventListener(&#39;popstate&#39;, (event) &#x3D;&gt; &#123;\n        wx.miniProgram.navigateBack();\n    &#125;);\n&#125;\n\nbackground-size不生效view &#123;\n    background: url(&#39;xxx.png&#39;) no-repeat;\n    background-size: 100% 100%;\n&#125;\n如此写法时，background-size不会生效，要使用background-image属性声明背景图片\nview &#123;\n    background-image: url(&#39;xxx.png&#39;);\n    background-repeat: no-repeat;\n    background-size: 100% 100%;\n&#125;\n\nEcharts不显示使用Echarts绘制canvas时，必须给其父级盒子声明宽高，并且此view中不能拥有其他挤占宽高的元素\n&lt;view class&#x3D;&quot;chart-box&quot;&gt;\n\t&lt;ec-canvas ...&gt;&lt;&#x2F;ec-canvas&gt;\n&lt;&#x2F;view&gt;\n.chart-box &#123;\n    width: 100rpx;\n    height: 100rpx;\n&#125;\n\nEcharts层级问题\n\n\n\n\n\n提示\n首先确认：打开手机扫码确认问题在真机也会同时出现\n\n使用canvas时，层级会自动置于最高，解决办法：给canvas元素增加属性type=&quot;2d&quot;Echarts文档中写明，如不配置force-use-old-canvas=&quot;true&quot;的情况下，只要用户的基础库版本 &gt;&#x3D; 2.9.0，会自动为其中的canvas添加该属性，但效果显示并非如此通过翻看源码查到，如果添加isUseNewCanvas，会使用新版canvas，但结果也并非如此，于是尝试更改源码，将其中的ec-canvas.js文件中的data.isUseNewCanvas改为true得以解决\n\n给组件使用hidden属性时失效组件的hidden显示要使用view套一层，控制外层view的hidden\n引入字体wx.loadFontFace(&#123;\n    family: &#39;zhenyan&#39;,\n    source: &quot;url(&#39;https:&#x2F;&#x2F;xxx&#x2F;zhenyan.ttf&#39;)&quot;,\n    global: true\n&#125;)\n\n\n\n\n\n\n\n\n注意\nscopes: native配置后wxss文件中会失效app.js文件中引用无效\n\n小程序canvas绘制最新版本和web语法一致，但ctx对象需要如下操作\nlet query &#x3D; wx.createSelectorQuery().in(this);\nquery.select(&#39;#canvas&#39;).fields(&#123;\n    node: true,\n    size: true\n&#125;).exec(resp &#x3D;&gt; &#123;\n    const width &#x3D; resp[0].width;\n    const height &#x3D; resp[0].height;\n    let canvas &#x3D; resp[0].node;\n    let ctx &#x3D; canvas.getContext(&#39;2d&#39;);\n    let dpr &#x3D; wx.getSystemInfoSync().pixelRatio;\n    canvas.width &#x3D; width * dpr;\n    canvas.height &#x3D; height * dpr;\n\n    &#x2F;&#x2F; 绘制逻辑\n&#125;);\n\nwx.getUserProfile()接口调用不报错直接进入faildesc属性必填，且不可过长\nvant组件引入后不生效尝试重启编译器，引入未使用过的组件，第一次渲染不会生效\n背景图片时而可以用静态地址，时而不行经测试，怀疑是过大的图片文件不可以用静态地址解决方式：换用image元素做背景\n","slug":"wx小程序-bug记录/index","date":"2022-07-29T16:00:00.000Z","categories_index":"bug","tags_index":"bug,wx小程序","author_index":"Life Experiencer"},{"id":"ee1781b2ca281272a7524c04a8bacf0a","title":"前端导出","content":"1.引入工具类&lt;script lang&#x3D;&quot;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.sheetjs.com&#x2F;xlsx-0.18.7&#x2F;package&#x2F;dist&#x2F;xlsx.full.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n(官方文档)[https://github.com/SheetJS/sheetjs]\n2.封装导出&#x2F;&#x2F; 导出按钮点击事件\nfunction onExportClick(dataSrc) &#123;\n    var listdata &#x3D; dataSrc;\n    var typeList &#x3D; [];  &#x2F;&#x2F; 记录录入的类型\n    var tableData &#x3D; [];&#x2F;&#x2F;表格数据\n    var titleRow &#x3D; [&quot;突发事件处置表&quot;]; &#x2F;&#x2F; 标题行\n    var secondRow &#x3D; [&quot;日期&quot;];\n    var thirdRow &#x3D; [&quot;&quot;];\n    var data &#x3D; [];\n    \n    listdata.forEach(item &#x3D;&gt; &#123;\n        if (secondRow.indexOf(item.EventParentTypeName) &#x3D;&#x3D; -1) &#123;\n            secondRow.push(item.EventParentTypeName, &quot;&quot;);\n            typeList.push(item.EventParentTypeId);\n        &#125;\n    &#125;);\n    \n    secondRow.push(&quot;发布情报板（条）&quot;);\n    \n    for (var i &#x3D; 0; i &lt; typeList.length; i++) &#123;\n        thirdRow.push(&quot;次数&quot;, &quot;时长(min)&quot;);\n    &#125;\n    thirdRow.push(&quot;&quot;);\n    tableData.push(titleRow, secondRow, thirdRow);\n    \n    &#x2F;&#x2F; 组装数据成对象数组\n    var dataObjList &#x3D; [];\n    listdata.forEach(item &#x3D;&gt; &#123;\n        var time &#x3D; item.EventReportDate;\n        time +&#x3D; item.Shift &#x3D;&#x3D; 1 ? &quot;（白班）&quot; : &quot;（夜班）&quot;;\n        var index &#x3D; dataObjList.findIndex(e &#x3D;&gt; e.time &#x3D;&#x3D; time);\n        if (index &#x3D;&#x3D; -1) &#123;\n            dataObjList.push(&#123;\n                time,\n                count: item.InfoBoardNumber,\n                list: [&#123;\n                    times: item.EventNumber,\n                    duration: item.Duration,\n                    id: item.EventParentTypeId\n                &#125;]\n            &#125;);\n        &#125; else &#123;\n            dataObjList[index].count +&#x3D; item.InfoBoardNumber;\n            dataObjList[index].list.push(&#123;\n                times: item.EventNumber,\n                duration: item.Duration,\n                id: item.EventParentTypeId\n            &#125;);\n        &#125;\n    &#125;);\n    &#x2F;&#x2F; 将对象数组转为对应格式\n    dataObjList.forEach(item &#x3D;&gt; &#123;\n        data.push(item.time);\n        typeList.forEach(id &#x3D;&gt; &#123;\n            var index &#x3D; item.list.findIndex(e &#x3D;&gt; e.id &#x3D;&#x3D; id);\n            if (index &#x3D;&#x3D; -1) &#123;\n                data.push(&quot;&quot;, &quot;&quot;);\n            &#125; else &#123;\n                data.push(item.list[index].times, item.list[index].duration);\n            &#125;\n        &#125;);\n        data.push(item.count);\n        tableData.push(data);\n        data &#x3D; [];\n    &#125;);\n    \n    var sheet &#x3D; XLSX.utils.aoa_to_sheet(tableData, &#123; raw: true &#125;);\n    &#x2F;&#x2F; 配置跨行跨列\n    merge &#x3D; [\n        &#123; \n            s: &#123; r: 0, c: 0 &#125;, \n            e: &#123; r: 0, c: secondRow.length &#125; \n        &#125;,\n        &#123;\n            s: &#123; r: 1, c: 0&#125;,\n            e: &#123; r: 2, c: 0&#125;\n        &#125;\n    ];\n    for (var i &#x3D; 0; i &lt; typeList.length; i++) &#123;\n        merge.push(\n            &#123;\n                s: &#123; r: 1, c: 2 * i + 1&#125;,\n                e: &#123; r: 1, c: 2 * i + 2&#125;\n            &#125;\n        );\n    &#125;\n    sheet[&#39;!merges&#39;] &#x3D; merge;\n    saveAs(sheet2blob(sheet), &#39;突发事件处置表&#39; + formatDate(new Date(), &quot;yyyy-MM-dd&quot;) + &#39;.xlsx&#39;);\n&#125;\n\n&#x2F;&#x2F; 导出表格\nfunction saveAs(blob, filename) &#123;\n    if (window.navigator.msSaveOrOpenBlob) &#123;\n        navigator.msSaveBlob(blob, filename);\n    &#125; else &#123;\n        var link &#x3D; document.createElement(&#39;a&#39;);\n        var body &#x3D; document.querySelector(&#39;body&#39;);\n\n        link.href &#x3D; window.URL.createObjectURL(blob);\n        link.download &#x3D; filename;\n\n        &#x2F;&#x2F; fix Firefox\n        link.style.display &#x3D; &#39;none&#39;;\n        body.appendChild(link);\n\n        link.click();\n        body.removeChild(link);\n\n        window.URL.revokeObjectURL(link.href);\n    &#125;;\n&#125;\n\nfunction sheet2blob(sheet, sheetName) &#123;\n    sheetName &#x3D; sheetName || &#39;sheet1&#39;;\n    var workbook &#x3D; &#123;\n        SheetNames: [sheetName],\n        Sheets: &#123;&#125;\n    &#125;;\n    workbook.Sheets[sheetName] &#x3D; sheet;\n    &#x2F;&#x2F; 生成excel的配置项\n    var wopts &#x3D; &#123;\n        bookType: &#39;xlsx&#39;, &#x2F;&#x2F; 要生成的文件类型\n        bookSST: false, &#x2F;&#x2F; 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性\n        type: &#39;binary&#39;\n    &#125;;\n    var wbout &#x3D; XLSX.write(workbook, wopts);\n    var blob &#x3D; new Blob([s2ab(wbout)], &#123; type: &quot;application&#x2F;octet-stream&quot; &#125;);\n    &#x2F;&#x2F; 字符串转ArrayBuffer\n    function s2ab(s) &#123;\n        var buf &#x3D; new ArrayBuffer(s.length);\n        var view &#x3D; new Uint8Array(buf);\n        for (var i &#x3D; 0; i !&#x3D; s.length; ++i) view[i] &#x3D; s.charCodeAt(i) &amp; 0xFF;\n        return buf;\n    &#125;\n    return blob;\n&#125;\n\n&#x2F;&#x2F;格式化日期,\nfunction formatDate(date, format) &#123;\n    var paddNum &#x3D; function (num) &#123;\n        num +&#x3D; &quot;&quot;;\n        return num.replace(&#x2F;^(\\d)$&#x2F;, &quot;0$1&quot;);\n    &#125;\n    &#x2F;&#x2F;指定格式字符\n    var cfg &#x3D; &#123;\n        yyyy: date.getFullYear() &#x2F;&#x2F;年 : 4位\n        , yy: date.getFullYear().toString().substring(2)&#x2F;&#x2F;年 : 2位\n        , M: date.getMonth() + 1  &#x2F;&#x2F;月 : 如果1位的时候不补0\n        , MM: paddNum(date.getMonth() + 1) &#x2F;&#x2F;月 : 如果1位的时候补0\n        , d: date.getDate()   &#x2F;&#x2F;日 : 如果1位的时候不补0\n        , dd: paddNum(date.getDate())&#x2F;&#x2F;日 : 如果1位的时候补0\n        , hh: date.getHours()  &#x2F;&#x2F;时\n        , mm: date.getMinutes() &#x2F;&#x2F;分\n        , ss: date.getSeconds() &#x2F;&#x2F;秒\n    &#125;\n    format || (format &#x3D; &quot;yyyy-MM-dd hh:mm:ss&quot;);\n    return format.replace(&#x2F;([a-z])(\\1)*&#x2F;ig, function (m) &#123; return cfg[m]; &#125;);\n&#125;\n\n\n\n\n\n\n\n提示\n原场景中的dataSrc如下\n\n\n&#x2F;&#x2F; 原始数据 （原场景为ajax请求获取到的数据）\nvar dataSrc &#x3D; [\n    &#123;\n        &quot;Shift&quot;: 1,\n        &quot;EventReportDate&quot;: &quot;2022-04-25&quot;,\n        &quot;EventParentTypeId&quot;: 12,\n        &quot;EventParentTypeName&quot;: &quot;测试事件&quot;,\n        &quot;EventNumber&quot;: 5,\n        &quot;Duration&quot;: 0.0,\n        &quot;InfoBoardNumber&quot;: 0\n    &#125;,\n    &#123;\n        &quot;Shift&quot;: 1,\n        &quot;EventReportDate&quot;: &quot;2022-04-26&quot;,\n        &quot;EventParentTypeId&quot;: 12,\n        &quot;EventParentTypeName&quot;: &quot;测试事件&quot;,\n        &quot;EventNumber&quot;: 3,\n        &quot;Duration&quot;: 0.0,\n        &quot;InfoBoardNumber&quot;: 0\n    &#125;,\n    &#123;\n        &quot;Shift&quot;: 1,\n        &quot;EventReportDate&quot;: &quot;2022-04-27&quot;,\n        &quot;EventParentTypeId&quot;: 12,\n        &quot;EventParentTypeName&quot;: &quot;测试事件&quot;,\n        &quot;EventNumber&quot;: 4,\n        &quot;Duration&quot;: 0.0,\n        &quot;InfoBoardNumber&quot;: 0\n    &#125;,\n    &#123;\n        &quot;Shift&quot;: 2,\n        &quot;EventReportDate&quot;: &quot;2022-04-27&quot;,\n        &quot;EventParentTypeId&quot;: 12,\n        &quot;EventParentTypeName&quot;: &quot;测试事件&quot;,\n        &quot;EventNumber&quot;: 2,\n        &quot;Duration&quot;: 0.0,\n        &quot;InfoBoardNumber&quot;: 0\n    &#125;,\n    &#123;\n        &quot;Shift&quot;: 1,\n        &quot;EventReportDate&quot;: &quot;2022-04-29&quot;,\n        &quot;EventParentTypeId&quot;: 1,\n        &quot;EventParentTypeName&quot;: &quot;天气事件&quot;,\n        &quot;EventNumber&quot;: 8,\n        &quot;Duration&quot;: 33001.634283333333,\n        &quot;InfoBoardNumber&quot;: 4\n    &#125;\n];","slug":"前端导出/index","date":"2022-07-01T16:00:00.000Z","categories_index":"工具类","tags_index":"导出","author_index":"Life Experiencer"},{"id":"77f748c7cea4ef5fb4d783ef512007b4","title":"前端压缩","content":"1.引入JSZip&lt;script src&#x3D;&quot;jszip.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;jszip-utils.js&quot;&gt;&lt;&#x2F;script&gt;\n\njszip.jsjszip-utils.js\n2.封装工具类&#x2F;**\n * 压缩\n * @param file 文件 类型为：File &#x2F; FileList\n * @param packageName 压缩包名称\n *&#x2F;\nfunction compressFiles(files, packageName) &#123;\n    let zip &#x3D; new JSZip();\n    &#x2F;&#x2F; 如果类型为File\n    if (Object.prototype.toString.call(files) &#x3D;&#x3D;&#x3D; &#39;[object File]&#39;) &#123;\n        let reader &#x3D; new FileReader();\n        reader.readAsArrayBuffer(files);\n        reader.addEventListener(&quot;loadend&quot;, function(e) &#123;\n            let blob &#x3D; new Blob([e.target.result], &#123; type: file.type &#125;);\n            zip.file(file.name, blob);\n            zip.generateAsync(&#123; type: &quot;blob&quot; &#125;).then(bl &#x3D;&gt; &#123;\n                saveAs(bl, packageName);\n            &#125;);\n        &#125;);\n    &#x2F;&#x2F; 如果类型为FileList\n    &#125; else if (Object.prototype.toString.call(files) &#x3D;&#x3D;&#x3D; &#39;[object FileList]&#39;) &#123;\n        let reader &#x3D; new FileReader();\n        let i &#x3D; 0;\n        &#x2F;&#x2F; 递归读取流\n        reader.addEventListener(&quot;loadend&quot;, function(e) &#123;\n            &#x2F;&#x2F; 读取后的流写入zip中\n            let blob &#x3D; new Blob([e.target.result], &#123; type: files[i].type &#125;);\n            zip.file(files[i].name, blob);\n            if (i &#x3D;&#x3D;&#x3D; Object.keys(files).length - 1) &#123;\n                &#x2F;&#x2F; 如果全部压缩后，下载\n                zip.generateAsync(&#123; type: &quot;blob&quot; &#125;).then(bl &#x3D;&gt; &#123;\n                    saveAs(bl, packageName);\n                &#125;);\n            &#125; else &#123;\n                reader.readAsArrayBuffer(files[++i]);\n            &#125;\n        &#125;);\n        reader.readAsArrayBuffer(files[i]);\n    &#125;\n&#125;\n\n&#x2F;**\n * 解压本地文件\n * @param file 压缩文件\n * @param callback 解压后的回调函数 参数分别为文件路径和文件\n *&#x2F;\nfunction uncompressNative(file, callback) &#123;\n    JSZip.loadAsync(file).then(function(zip) &#123;\n        zip.forEach((path, file) &#x3D;&gt; &#123;\n            callback(path, file);\n        &#125;);\n    &#125;, function() &#123;\n        console.error(&#39;解压失败&#39;);\n    &#125;);\n&#125;\n\n&#x2F;**\n * 解压线上文件\n * @param path \n * @param callback 解压后的回调 参数为单个文件\n *&#x2F;\nfunction uncompressOnline(path, callback) &#123;\n    let promise &#x3D; new JSZip.external.Promise(function (resolve, reject) &#123;\n        JSZipUtils.getBinaryContent(path, function(err, data) &#123;\n            if (err) &#123;\n                reject(err);\n            &#125; else &#123;\n                resolve(data);\n            &#125;\n        &#125;);\n    &#125;);\n    promise.then(JSZip.loadAsync)\n    .then(function(zip) &#123;\n        for (key in zip.files) &#123;\n            zip.file(key).async(&quot;blob&quot;).then(blob &#x3D;&gt; &#123;\n                let file &#x3D; new File([blob], zip.files[key].name);\n                callback(file);\n            &#125;);\n        &#125;\n    &#125;)\n    .then(function success(text) &#123;\n        \n    &#125;, function error(e) &#123;\n        \n    &#125;);\n&#125;\n\n&#x2F;**\n * 下载\n * @param blob 文件二进制流\n * @param filename 文件名称\n *&#x2F;\nfunction saveAs(blob, filename) &#123;\n    if (window.navigator.msSaveOrOpenBlob) &#123;\n        navigator.msSaveBlob(blob, filename);\n    &#125; else &#123;\n        var link &#x3D; document.createElement(&#39;a&#39;);\n        var body &#x3D; document.querySelector(&#39;body&#39;);\n\n        link.href &#x3D; window.URL.createObjectURL(blob);\n        link.download &#x3D; filename;\n\n        &#x2F;&#x2F; fix Firefox\n        link.style.display &#x3D; &#39;none&#39;;\n        body.appendChild(link);\n\n        link.click();\n        body.removeChild(link);\n\n        window.URL.revokeObjectURL(link.href);\n    &#125;;\n&#125;","slug":"前端压缩/index","date":"2022-07-01T16:00:00.000Z","categories_index":"工具类","tags_index":"压缩","author_index":"Life Experiencer"},{"id":"8091d222d8427423209f6c7e976395c4","title":"防抖和节流","content":"防抖\n\n\n\n\n\n场景\n所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n非立即执行版本function debounce(func, wait) &#123;\n    let timeout;\n    return function() &#123;\n        const context &#x3D; this;\n        const args &#x3D; [...arguments];\n        &#x2F;&#x2F; 如果当前已经存在延时函数，则重新计时\n        if (timeout) clearTimeout(timeout);\n        timeout &#x3D;  setTimeout(() &#x3D;&gt; &#123;\n            func.apply(context, args);\n        &#125;, wait);\n    &#125;\n&#125;\n\n立即执行版function debounce(func, wait) &#123;\n    let timeout;\n    return function () &#123;\n        const context &#x3D; this;\n        const args &#x3D; [...arguments];\n        if (timeout) clearTimeout(timeout);\n        const callNow &#x3D; !timeout;\n        timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;\n            timeout &#x3D; null;\n        &#125;, wait);\n        if (callNow) func.apply(context, args);\n    &#125;;\n&#125;\n\n节流\n\n\n\n\n\n场景\n所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数，节流会稀释函数的执行频率。\n\n时间戳function throttle(func, wait) &#123;\n    var previous &#x3D; 0;\n    return function() &#123;\n        let now &#x3D; Date.now();\n        let context &#x3D; this;\n        let args &#x3D; arguments;\n        if (now - previous &gt; wait) &#123;\n            func.apply(context, args);\n            previous &#x3D; now;\n        &#125;\n    &#125;\n&#125;\ncontent.onmousemove &#x3D; throttle(count,1000);\n\n定时器function throttle(func, wait) &#123;\n    let timeout;\n    return function() &#123;\n        let context &#x3D; this;\n        let args &#x3D; arguments;\n        if (!timeout) &#123;\n            timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;\n                timeout &#x3D; null;\n                func.apply(context, args)\n            &#125;, wait)\n        &#125;\n\n    &#125;\n&#125;","slug":"防抖和节流/index","date":"2022-06-01T16:00:00.000Z","categories_index":"效率优化","tags_index":"防抖,节流","author_index":"Life Experiencer"},{"id":"e731b129ad8438b546830de537cc0a95","title":"Web基础 bug记录","content":"使用iFrame时，内嵌页面出现滚动条且高度不对\n\n\n\n\n\n\n\n\n原因：和img出现在div时一致，因为iFrame是行内元素，基线原因导致\n","slug":"Web基础-bug记录/index","date":"2022-05-16T16:00:00.000Z","categories_index":"bug","tags_index":"bug,web前端基础","author_index":"Life Experiencer"},{"id":"bec3eed037605986e82f30f910c0b6ea","title":"layui bug记录","content":"首次加载弹框时，背景闪白问题\n\n\n\n\n\n\n\n\n原因：源码layui.css中，存在样式：\n.layui-layer-load &#123;\n    background: url(loading-1.gif) center center no-repeat #eee;\n&#125;\n\n\n\n\n\n\n\n\n\n\n修改样式中颜色即可\n.layui-layer-load &#123;\n    background: url(loading-1.gif) center center no-repeat rgba(0, 0, 0, .2);\n&#125;","slug":"layui-bug记录/index","date":"2022-04-13T16:00:00.000Z","categories_index":"bug","tags_index":"bug,layui","author_index":"Life Experiencer"},{"id":"997108380504e887eb3e4c9fa356e3bd","title":"JS 垃圾回收","content":"垃圾回收机制垃圾回收有两种方式：标记清除和引用计数\n1. 引用计数计算所有变量被引用的次数，为0则可以清除\n缺点: 如果两个变量循环引用，则全部无法清除\n2. 标记清除垃圾收集器会在运行时将所有内存中的变量做上标记，尝试从根部触及所有的变量，无法触达的则视为可清除的变量\n从2012年开始，所有现代浏览器都使用了标记清除的方式\n内存泄漏1. 全局变量function demo() &#123;\n    this.field &#x3D; 1;\n&#125;\ndemo(); &#x2F;&#x2F; 这里window对象被添加了一个属性，而未被销毁，该变量从全局出发可以通过window触达，所以无法被回收\n\n2. 闭包function demo() &#123;\n    let num &#x3D; 1;\n    return () &#x3D;&gt; &#123;\n        console.log(num++);\n    &#125;\n&#125;\ndemo()();       &#x2F;&#x2F; 1\ndemo()();       &#x2F;&#x2F; 1\n\nlet fn &#x3D; demo();\nfn();           &#x2F;&#x2F; 1\ndemo()();       &#x2F;&#x2F; 1\nfn();           &#x2F;&#x2F; 2\nfn &#x3D; null;\nfn &#x3D; demo();\nfn();           &#x2F;&#x2F; 1\n\n这里在demo函数的闭包被直接调用时，会被认为没有其他内容可以继续触达num变量，所以内存被释放，再次调用还会打印1，然而当我们把demo函数返回的闭包函数接收下来时，则一直有内容可以触达num变量，所以再次打印结果为2，我们可以通过赋值为null的方式手动清空内存\n3. DOM 引用在js中有对Dom的引用，然而Dom已经销毁，此时其实对其引用已经没有作用，但仍然无法被销毁\n避免方案\n小心谨慎地使用全局变量\n使用闭包时要注意\n计时器里的回调没用时要记得销毁\n可以使用WeakSet和WeakMap，它们对于值的使用都是不计入垃圾回收机制的，表示为弱引用\n\n","slug":"JS垃圾回收/index","date":"2022-04-01T16:00:00.000Z","categories_index":"效率优化","tags_index":"JS,垃圾回收","author_index":"Life Experiencer"},{"id":"d4d5e8b67369f1d79a080e310bf56e19","title":"Cookie和Token令牌","content":"什么是Cookie？为什么要有Cookie？\n\n\n\n\n\n\n\n\n一般接口但是通过HTTP协议来进行数据交换的，而HTTP协议的特点是，无状态，工作前通过三次握手建立连接，工作完成后立刻通过四次挥手断开连接，每次连接都是独立存在的，没有任何状态将请求串联成一个整体，因此每次都需要重新验证是身份，即耗费性能，又不安全。Cookie可以作为一个状态保存的状态机，当用户第一次和服务器验证通过后，服务器会发送一个Cookie并使用set-cookie令客户端将自己的Cookie保存起来，下一次发送请求的时候，直接带上Cookie即可，服务器检测到客户端发送的Cookie与其保存的Cookie一致时，则直接信任该连接，不再进行验证操作。\n\nToken令牌\n\n\n\n\n\n\n\n\nToken，简单来说，就是类似 cookie 的一种验证信息，客户端通过登录验证后，服务器会返回给客户端一个加密的 token，然后当客户端再次向服务器发起连接时，带上token，服务器直接对token进行校验即可完成权限校验。\n有了 Cookie 为什么还需要 Token？\n\n\n\n\n\n\n\n\nCookie 作为 HTTP 规范，其出现历史久远，因此存在一些历史遗留问题，比如跨域限制等，并且 Cookie 作为 HTTP 规范中的内容，其存在默认存储以及默认发送的行为，存在一定的安全性问题。相较于 Cookie，token 需要自己存储，自己进行发送，不存在跨域限制，因此 Token 更加的灵活，没有 Cookie 那么多的“历史包袱”束缚，在安全性上也能够做更多的优化。\n\nToken的优势\n\n\n\n\n\n\n\n\n在安全性方面，token 能防止 csrf 攻击。在扩展性方面，token 可以处理多端的身份验证，不仅仅局限于浏览器，只要客户端能对 token 进行储存就行。token 在跨域共享资源上表现惊艳，只要不同域的服务器之间约定好签名规则，大家都是一家人！token 可以携带丰富的用户信息，只要不怕别人知道，你想传什么随你便！Cookie 大小4KB，Cookie过期时间一般为1个月。\n","slug":"Cookie和Token令牌/index","date":"2022-02-14T16:00:00.000Z","categories_index":"知识点","tags_index":"Cookie,Token令牌","author_index":"Life Experiencer"},{"id":"77cefb5fd0cde76aa6ec39dbc2ce3657","title":"ajax发送文件","content":"const sendFormData &#x3D; function() &#123;\n    const file &#x3D; new File();\n    const form &#x3D; new FormData();\n    form.append(&#39;fileData&#39;, file, &#39;文件名.xlsx&#39;);\n    form.append(&#39;id&#39;, 0);\n\n    $.ajax(&#123;\n        url: &#39;&#x2F;xxx&#39;,\n        type: &#39;POST&#39;,\n        data: form,\n        processData: false, &#x2F;&#x2F; 告诉jQuery不要处理发送的数据\n        contentType: false, &#x2F;&#x2F; 告诉jQuery不要设置content-type请求头\n    &#125;).then(res &#x3D;&gt; &#123;\n        \n    &#125;);\n&#125;","slug":"ajax发送文件/index","date":"2021-09-12T16:00:00.000Z","categories_index":"jQuery","tags_index":"jQuery,前后端交互,ajax","author_index":"Life Experiencer"},{"id":"fd4deaa8e285f4ef9f15cf7bee668bc9","title":"TCP三次握手和四次挥手","content":"三次握手\n\n\n\n\n\n提示\n三次握手就是为了确保双方正常连接\n\nC -&gt; SS -&gt; CC -&gt; S\n主动打开连接的是客户端被动打开连接的是服务端\n第一次握手证明客户端发送能力正常第二次握手证明服务端接受能力、发送能力正常第三次握手证明客户端接收能力正常\n第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态\n第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态\n第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手\n四次挥手C -&gt; SS -&gt; CS -&gt; CC -&gt; S\n第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态\n第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态\n第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成\n","slug":"TCP三次握手和四次挥手/index","date":"2021-09-01T16:00:00.000Z","categories_index":"知识点","tags_index":"TCP,三次握手,四次挥手","author_index":"Life Experiencer"},{"id":"fd888ffbf7087b4ba83a165597c715b7","title":"Element bug记录","content":"Element.ui使用el-tree组件，一键展开或关闭expandAll() &#123;\n    for (let key in this.$refs.tree.store.nodesMap) &#123;\n        this.$refs.tree.store.nodesMap[key].expanded &#x3D; true;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n注意\n  需要在el-tree组件上添加属性node-key=&quot;id&quot;，用以生成NodesMap，才可以进行遍历\n\nel-upload上传标签改变大小* &#123;\n    --uploadWidth: 70px;\n&#125;\n\n.el-upload--picture-card &#123;\n    width: var(--uploadWidth);\n    height: var(--uploadWidth);\n&#125;\n\n.el-upload &#123;\n    width: var(--uploadWidth);\n    height: var(--uploadWidth);\n    line-height: var(--uploadWidth);\n&#125;\n\n.el-upload-list--picture-card .el-upload-list__item &#123;\n    width: var(--uploadWidth);\n    height: var(--uploadWidth);\n    line-height: var(--uploadWidth);\n&#125;\n\n.el-upload-list--picture-card .el-upload-list__item-thumbnail &#123;\n    width: var(--uploadWidth);\n    height: var(--uploadWidth);\n    line-height: var(--uploadWidth);\n&#125;\n\n.avatar &#123;\n    width: var(--uploadWidth);\n    height: var(--uploadWidth);\n&#125;\n\nElement Plus\n\n\n\n\n\n提示\n  暂无\n\n","slug":"Element-bug记录/index","date":"2021-08-16T16:00:00.000Z","categories_index":"bug","tags_index":"bug,element","author_index":"Life Experiencer"},{"id":"2d463effdc98de85ee0a0b453c60fead","title":"Vue bug记录","content":"Vue2进入页面默认查找动态生成的内容，查找结果为空\n\n\n\n\n\n\n\n\n首先，查找元素应该在mounted生命周期中，因为此时页面已经完成渲染，其次，动态生成的元素，如果其数据是异步获取，应该在获取到以后，进行查找，并使用Vue实例的方法$nextTick(); 因为此时数据获取到了，但页面内容并未渲染，在下一帧时才进行渲染\n父组件生命周期钩子执行顺序\n\n\n\n\n\n\n\n\n从外到内再从内到外父组建： beforeCreate -&gt; created -&gt; beforeMount子组件： -&gt; beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted父组件： -&gt; mounted\nVue3Vue3声明对象或数组后，不失去响应的赋值方式源代码：\nlet array: number[] &#x3D; reactive([]);\t\t\t&#x2F;&#x2F; proxy...\narray &#x3D; reactive([]);\t\t\t&#x2F;&#x2F; proxy...\narray &#x3D; [];\t\t\t&#x2F;&#x2F; [ ]\n\n\n\n\n\n\n\n提示\n可见，直接赋值[ ]，会让变量失去响应，再次赋值reactive()又不符合规范\n\n解决方式1Object.assign函数的原理是遍历所有可枚举和自有属性从源对象赋值到目标对象\nconst array: number &#x3D; reactive([]);\nObject.assign(array, [1,2,3]);\n\n解决方式2使用状态机管理代理对象\nconst state: IState &#x3D; reactive(&#123;\n    array: []\n&#125;);\nstate.array &#x3D; [];\n\nVue3样式穿透\n\n\n\n\n\n\n注意\n1.&lt;style&gt;标签设置scoped属性2.使用:(deep):3.html元素及css选择器均不能为根节点\n\n&lt;main&gt;\n    &lt;xxx&gt;&lt;&#x2F;xxx&gt;\n&lt;&#x2F;main&gt;\nmain &#123;\n    :deep(.xxx) &#123;\n        width: 12px;\n        height: 12px;\n        border-radius: 50%;\n    &#125;\n&#125;\n\nVue3设置子组件样式在父级无法穿透组件最外层级嵌套一层div\n&lt;div&gt;\n    &lt;main&gt;\n\n    &lt;&#x2F;main&gt;\n&lt;&#x2F;div&gt;","slug":"Vue-bug记录/index","date":"2021-05-08T16:00:00.000Z","categories_index":"bug","tags_index":"bug,vue","author_index":"Life Experiencer"},{"id":"59630f6cb50b5d1b95c17c1cbb07d624","title":"前端知识点之CSS汇总篇","content":"网页居中方式一、元素的分类元素分为两种：\n\n\n\n\n\n\n\n\n\n块级元素：独占一行，块级元素中可以设置存放行级元素\n行级元素：在一行中排列，超出宽度自动换行\n特殊的显示效果：\n\n\n\n\n\n\n\n\n\n行块元素：依然是行级元素，但是具有盒子模型的功能\n行弹性元素：依然是行级元素，但是具有弹性布局的功能\n二、元素的居中方式1. 不考虑浮动、定位的情况下，采用的是**网页标准文档流布局**1.1 水平居中方式：1.1.1 text-align:center\n\n\n\n\n\n\n\n\n由父级元素（包括块元素、行快元素）设置，行级元素展现居中状态父级要有宽度，且大于内容宽度   相当于把内容都当作文本进行居中\n注：对单独的行级元素设置margin和padding是没有任何效果的，设置为行块之后才可以设置宽度高度。若不设置宽高就默认为块元素\n1.1.2 margin:auto;\n\n\n\n\n\n\n\n\n只能并且必须给块级元素使用，必须要设置宽度\n注：对于设置了宽高的块级元素设置margin时，只能水平auto居中margin:auto不能给行块设置\n\n\n\n\n\n\n\n\n\n若想达到行块元素居中，就需要在父级设置text-align : center 来实现\n1.1.3 padding\n\n\n\n\n\n\n\n\n父级是行块元素且不设置任何宽高时，内容会撑开父级，这里的居中方式为padding：0  30px;进行视觉居中\n1.1.4 justify-content:center\n\n\n\n\n\n\n\n\n父级的显示方式必须为弹性布局\n父级的主轴排列方向为水平\n1.2. 垂直居中方式：1.2.1 vertical-align : middle;\n\n\n\n\n\n\n\n\n 元素必须为行级元素或者行块元素显示方式\n 它控制的是元素的水平对齐线，默认为baseline\n 多个元素相互对齐，因此如果希望多个元素垂直对齐，那么它们都要设置该属性才可以生效\n\n1.2.2 padding\n\n\n\n\n\n\n\n\n父级元素为块级或行块显示方式，padding 30px 0 ； 进行居中\n1.2.3 line-height\n\n\n\n\n\n\n\n\n为块级或行块元素，设置height像素值，将行高与高度设置一样之后就会居中，只适用于元素内只有单行的情况\n1.2.4 align-items:center;\n\n\n\n\n\n\n\n\n父级的显示方式必须为弹性布局\n父级的交叉轴为垂直方向\n2. 浮动布局之后2.1 浮动的使用场景：\n\n\n\n\n\n\n\n\n没有水平居中要求的情况才使用浮动布局\n内容左右分布的情况 ，没有固定的位置，随页面改变\n如果设置了块级元素的宽度，但是希望把它放在同一行的情况\n2.2 水平居中：2.2.1 padding\n\n\n\n\n\n\n\n\n设置在父级行块元素中\n不需要解决塌陷问题\n2.3 垂直居中：2.3.1 line-height \n\n\n\n\n\n\n\n\n设置在父级元素中（块级、行块元素）\n一定要在父级块解决塌陷后才可以生效\n将高度与行高设置为一致后，内容会自动垂直居中\n只适用于元素内只有单行的情况\n2.3.2 padding\n\n\n\n\n\n\n\n\n设置在父级的行块元素中，不需要解决塌陷问题。\n3. 定位之后\n\n\n\n\n\n\n\n\n父级的元素设置为相对定位relative\n子元素设置position为绝对定位absolute时\n子元素的居中方式\ntop: 50%;\ntransform: translateY(-50%);","slug":"网页布局/index","date":"2021-01-26T16:00:00.000Z","categories_index":"知识点","tags_index":"CSS,面试题","author_index":"Life Experiencer"},{"id":"c61e32720888e2dc2db1b3a1cf94defc","title":"Vue双向绑定","content":"前言\n\n\n\n\n\n\n\n\nVue的双向绑定指的是v-model指令，而Vue实际是单向数据流单双向绑定指的是View层和Model层之间的映射关系react采取的是单向绑定Vue的v-model双向绑定实际上只是v-bind:value和v-on:input的语法糖（子组件不能直接修改父组件的属性值，而是通过事件的方式向上传递更新值，所以不能叫做双向数据流，只能叫做单向数据流）\nMVVM\n\n\n\n\n\n\n\n\nMVVM是基于MVC模式的进阶，实际上就是将复杂沉重的Controller的数据和逻辑处理部分抽离出来，用一个专门的对象ViewModel去管理。\nMVVM与Vue\n\n\n\n\n\n\n\n\nVue框架充当了其中ViewModel的作用，负责View层和Model层之间的通信，使开发变得简单\nObject.definePropertyObject.defineProperty(obj, prop, descriptor)方法会直接在一个对象上定义一个 新属性，或修改一个 对象 的 现有属性，并返回此对象，其参数具体为：\n\nobj：要定义属性的对象\nprop：要定义或修改的属性名称或 Symbol\ndescriptor：要定义或修改的属性描述符\n\n\n\n\n\n\n\n注意\n目标是对象属性，而不是对象一次只能定义或修改一个属性（当然有方案一次修改多个，Object.defineProperties()，但在vue中并不适用，因为vue并不能提前知道用户所传入对象具有什么属性，因此还是需要用Object.keys() + for循环的方式获取所有的key和value\n\nVue2的响应式原理的缺点\n只能拦截对象属性的get和set操作，比如无法拦截delete、in、方法调用 等操作\n动态添加新属性会丢失响应式（必须在data中声明，或者使用时用this.$set()设置新属性\n通过delete删除属性导致响应式丢失（需要使用this.$delete()删除属性\n使用数组索引 替换&#x2F;新增 元素会导致响应式丢失（使用this.$set()设置新元素\n一次只能对一个属性实现数据劫持，需要遍历对所有属性进行劫持\n数据结构复杂时（属性值为 引用类型数据），需要通过递归进行处理\n使用数组push、pop、shift、unshift、splice、sort、reverse等 原生方法 改变原数组时丢失响应式\n\n【扩展】Object.defineProperty 和 Array\n\n\n\n\n\n\n\n\n因为Vue2没有使用Object.defineProperty对Array操作进行拦截，所以大家通常认为Object.defineProperty不能对Array操作进行拦截，但其实这是一个误区，本身Array是一个对象，而Object.defineProperty操作对象就是对象的属性，所以是完全可以对Array的get和set进行拦截的，但为什么没有拦截呢？\n尤大在曾在GitHub的Issue中做过如下回复：\n对比Vue3变化看Vue2\n\n\n\n\n\n\n\n\n(2022&#x2F;12&#x2F;5Vue2使用Object.defineProperty    Vue3使用Proxy\n\n\n\n\n\n\n\n\n\n\nVue2中使用的Object.defineProperty无法实现监听数组下标的变化，导致通过数组下标添加元素，不能实时响应\nObject.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果属性值依旧为对象，则还需要深度遍历，消耗性能。\nProxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\n\n","slug":"Vue双向绑定/index","date":"2021-01-19T16:00:00.000Z","categories_index":"知识点","tags_index":"Vue,Vue双向绑定","author_index":"Life Experiencer"},{"id":"d429359e30d611fd2522983f73e3a623","title":"观察者模式 VS 发布订阅模式","content":"观察者模式\n\n\n\n\n\n\n\n\n本质是一种一对多的关系，一指的是目标对象，多指的是观察者，目标对象可以添加多个观察者，当目标对象需要被观测的状态发生改变时，就会通知所有的观察者，是一种紧耦合。\n示例代码&#x2F;&#x2F; 只是一种简单实现，并非只有这一种方式\n&#x2F;&#x2F; 定义一个目标对象\nclass Subject &#123;\n    constructor() &#123;\n        this.Observers &#x3D; [];\n        this.state &#x3D; &#39;初始状态&#39;;\n    &#125;\n    &#x2F;&#x2F;添加\n    add(observer) &#123;\n        this.Observers.push(observer);\n    &#125;\n    &#x2F;&#x2F;移除\n    remove(observer) &#123;\n        this.Observers.filter((item) &#x3D;&gt; item &#x3D;&#x3D;&#x3D; observer);\n    &#125;\n    &#x2F;&#x2F;通知所有观察者\n    notify() &#123;\n        this.Observers.forEach((item) &#x3D;&gt; &#123;\n            item.update();\n        &#125;);\n    &#125;\n    &#x2F;&#x2F;改变状态\n    setState(state) &#123;\n        this.state &#x3D; state;\n        this.notify(state);\n    &#125;\n&#125;\n&#x2F;&#x2F;定义观察者对象\nclass Observer &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  update(param) &#123;\n    console.log(&#39;接收更改状态：&#39; + param);\n  &#125;\n&#125;\n\nlet sub &#x3D; new Subject();\nlet obs1 &#x3D; new Observer(&quot;observer1&quot;);\nlet obs2 &#x3D; new Observer(&quot;observer2&quot;);\nsub.add(obs1);\nsub.add(obs2);\nsub.setState(&#39;更新&#39;);\n\n发布订阅模式\n\n\n\n\n\n\n\n\n发布订阅模式是一种多对多，通过中间的“经纪人”进行联系，“暗号”为topic，mqtt就是一种发布订阅模式，是一种松耦合。\n示例代码&#x2F;&#x2F; 报社\nclass Publisher &#123;\n    constructor(name, channel) &#123;\n        this.name &#x3D; name;\n        this.channel &#x3D; channel;\n    &#125;\n    &#x2F;&#x2F; 注册报纸\n    addTopic(topicName) &#123;\n        this.channel.addTopic(topicName);\n    &#125;\n    &#x2F;&#x2F; 推送报纸\n    publish(topicName) &#123;\n        this.channel.publish(topicName);\n    &#125;\n&#125;\n&#x2F;&#x2F; 订阅者\nclass Subscriber &#123;\n    constructor(name, channel) &#123;\n        this.name &#x3D; name;\n        this.channel &#x3D; channel;\n    &#125;\n    &#x2F;&#x2F;订阅报纸\n    subscribe(topicName) &#123;\n        this.channel.subscribeTopic(topicName, this);\n    &#125;\n    &#x2F;&#x2F;取消订阅\n    unSubscribe(topicName) &#123;\n        this.channel.unSubscribeTopic(topicName, this);\n    &#125;\n    &#x2F;&#x2F;接收推送\n    update(topic) &#123;\n        console.log(&#96;$&#123;topic&#125;已经送到$&#123;this.name&#125;家了&#96;);\n    &#125;\n&#125;\n&#x2F;&#x2F; 第三方平台\nclass Channel &#123;\n    constructor() &#123;\n        this.topics &#x3D; &#123;&#125;;\n    &#125;\n    &#x2F;&#x2F;报社在平台注册报纸\n    addTopic(topicName) &#123;\n        this.topics[topicName] &#x3D; [];\n    &#125;\n    &#x2F;&#x2F;报社取消注册\n    removeTopic(topicName) &#123;\n        delete this.topics[topicName];\n    &#125;\n    &#x2F;&#x2F;订阅者订阅报纸\n    subscribeTopic(topicName, sub) &#123;\n        if (this.topics[topicName]) &#123;\n            this.topics[topicName].push(sub);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;订阅者取消订阅\n    unSubscribeTopic(topicName, sub) &#123;\n        this.topics[topicName].forEach((item, index) &#x3D;&gt; &#123;\n        if (item &#x3D;&#x3D;&#x3D; sub) &#123;\n            this.topics[topicName].splice(index, 1);\n        &#125;\n        &#125;);\n    &#125;\n    &#x2F;&#x2F;平台通知某个报纸下所有订阅者\n    publish(topicName) &#123;\n        this.topics[topicName].forEach((item) &#x3D;&gt; &#123;\n            item.update(topicName);\n        &#125;);\n    &#125;\n&#125;\n\n对比总结思考\n\n\n\n\n\n\n\n\n可以理解为，以前快递员上门送货，后来快递太多了，为了增加效率，分工更明确一点，现在多了个中间站，菜鸟驿站，快递员方便了，这是在规模起来以后自然而然的选择。现在是人主动去拿快递，如果以后连这也嫌弃效率不高，怎么办？再加一层，菜鸟驿站派出机器人送。\n","slug":"观察者模式 VS 发布订阅模式/index","date":"2020-12-29T16:00:00.000Z","categories_index":"知识点","tags_index":"发布订阅模式,观察者模式","author_index":"Life Experiencer"}]