{"title":"前端知识点之HTML汇总篇","uid":"cd75f7c6287f064b0d8db8463d91e774","slug":"前端知识点之HTML汇总篇/index","date":"2023-06-18T16:00:00.000Z","updated":"2023-07-04T03:19:27.219Z","comments":true,"path":"api/articles/前端知识点之HTML汇总篇/index.json","keywords":null,"cover":[],"content":"<h3 id=\"1-src与href的区别\"><a href=\"#1-src与href的区别\" class=\"headerlink\" title=\"1. src与href的区别\"></a>1. <code>src</code>与<code>href</code>的区别</h3><p><strong>src</strong>: 表示对资源的引用，它所指向的内容会被直接嵌入到当前标签所在的位置，例如图片、js脚本等。当浏览器解析到该元素时，会立刻停止其他资源的下载和处理，直到将该资源加载、编译、执行完毕，所以一般都会将js放在页面底部去处理。<br><strong>href</strong>: 表示超文本引用，它指向的是一些网络资源，建立和当前元素或文本标签的链接关系。当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理。通常用在a标签、link标签上。</p>\n<h3 id=\"2-语义化\"><a href=\"#2-语义化\" class=\"headerlink\" title=\"2. 语义化\"></a>2. 语义化</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事儿。<br>语义化的优点有：</p>\n<ol>\n<li>对机器友好，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，还支持读屏软件根据文章自动生成目录。</li>\n<li>对开发者友好，能增强代码可读性，使层次结构更加清晰，便于团队的开发与维护。</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;header&gt;&lt;&#x2F;header&gt; &lt;!-- 头部 --&gt;\n&lt;section&gt;&lt;&#x2F;section&gt; &lt;!-- 区块 --&gt;\n&lt;nav&gt;&lt;&#x2F;nav&gt; &lt;!-- 导航栏 --&gt;\n&lt;main&gt;&lt;&#x2F;main&gt; &lt;!-- 主要区域 --&gt;\n&lt;aside&gt;&lt;&#x2F;aside&gt; &lt;!-- 侧边栏 --&gt;\n&lt;article&gt;&lt;&#x2F;article&gt; &lt;!-- 主要内容 --&gt;\n&lt;footer&gt;&lt;&#x2F;footer&gt; &lt;!-- 底部 --&gt;</code></pre>\n\n<h3 id=\"3-DOCTYPE-⽂档类型-的作⽤\"><a href=\"#3-DOCTYPE-⽂档类型-的作⽤\" class=\"headerlink\" title=\"3. DOCTYPE(⽂档类型) 的作⽤\"></a>3. <code>DOCTYPE</code>(⽂档类型) 的作⽤</h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。它不属于HTML标签，而是一条指令。<br>浏览器渲染页面的两种模式（可以通过document.compatMode来获取）：<br>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。<br>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</p>\n<h3 id=\"4-script标签中defer和async的区别\"><a href=\"#4-script标签中defer和async的区别\" class=\"headerlink\" title=\"4. script标签中defer和async的区别\"></a>4. script标签中<code>defer</code>和<code>async</code>的区别</h3><p>在浏览器的默认解析中，解析到script标签时会同步处理后续文档，也就是等待该js文件加载、编译、执行结束才会继续处理后续文档。<br><img src=\"/image/knowledge/defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"defer和async的区别\"><br>蓝色代表js脚本的网络加载时间，红色代表js脚本的执行时间，绿色代表html解析。</p>\n<p><strong>defer</strong>: 异步加载，最后处理<br><strong>async</strong>: 异步加载，同步执行</p>\n<p>注意：两种都对内嵌脚本无效，因为内容已经在html里了，无需加载</p>\n<h3 id=\"5-img的srcset属性和sizes属性的作用\"><a href=\"#5-img的srcset属性和sizes属性的作用\" class=\"headerlink\" title=\"5. img的srcset属性和sizes属性的作用\"></a>5. img的srcset属性和sizes属性的作用</h3><p>响应式页面中经常用到根据屏幕密度(即像素比，可以通过放大页面来调整)设置不同的图片，需要用到img标签的srcset属性，用于设置不同屏幕密度下，img自动加载不同图片</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img src&#x3D;&quot;image-128.png&quot; srcset&#x3D;&quot;image-256.png 2x, image-512.png 3x&quot; &#x2F;&gt;</code></pre>\n\n<p>当屏幕正常像素比时，会显示image-128.png，当调整缩放&gt;200% &amp;&amp; &lt; 300%时，则会显示image-512.png</p>\n<p>sizes属性可以用媒体查询的方法指定图像宽度，但在这里的宽度我们通常使用w单位而非px，计算w的方式如下：在通常的pc机中像素比为1，则sizes计算值为375px的时候，img实际宽度为375×1&#x3D;375w，当在iphone 678中，像素比为2，则img实际宽度为375×2&#x3D;750w，iphone plus或iphone X的机型中像素比为3，则img实际宽度为375×3&#x3D;1125w</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img \n  src&#x3D;&quot;image1.png&quot;\n  sizes&#x3D;&quot;(max-width: 376px) 375px, (max-width: 769px) 768px, 1024px&quot;\n  srcset&#x3D;&quot;\n    image1.png 375w,\n    image2.png 768w,\n    image3.png 1024w\n    &quot;\n&gt;</code></pre>\n\n<p>如此时，假如sizes计算宽度为375的情况下，在pc机中，显示的图片资源为image1，在iphone 678中显示image2，在iphone plus或iphone X中显示image3</p>\n<h3 id=\"6-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？\"><a href=\"#6-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？\" class=\"headerlink\" title=\"6. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\"></a>6. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><p>行内元素有：a b span img input select strong<br>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</p>\n<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>\n<p>常见的有：br、hr、img、input、link、meta<br>鲜见的有：area、base、col、colgroup、command、embed、keygen、param&gt;、source、track、wbr</p>\n<h3 id=\"7-web-work\"><a href=\"#7-web-work\" class=\"headerlink\" title=\"7. web work\"></a>7. web work</h3><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>web work（工作线程）是在HTML5中提出的概念，分成两种类型：专用线程(Dedicated Web Worker)和共享线程(Shared Web Worker)。<br>专用线程只能被创建它的脚本所使用<br>共享线程能够被不同的脚本使用</p>\n</div>\n<p>用途：将一些耗时的数据处理操作从主线程中剥离，让主线程专注于页面渲染和交互。</p>\n<ul>\n<li>懒加载</li>\n<li>文本分析</li>\n<li>流媒体数据处理</li>\n<li>canvas图形绘制</li>\n<li>图像处理</li>\n<li>……</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>同源限制</li>\n<li>无法访问DOM节点</li>\n<li>运行在另一个上下文，无法使用Window对象</li>\n<li>运行时不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果使用该线程频繁与主线程交互的话，主线程由于需要处理交互逻辑，仍有可能使页面发生阻塞</li>\n<li>共享线程可以被多个浏览上下文调用，但所有这些浏览上下文必须同源（相同协议、主机和端口号）</li>\n</ul>\n<p>具体使用方式可以复制下面两个文件进行测试：</p>\n<p>文件1：主线程html文件</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        Worker 输出内容：&lt;span id&#x3D;&#39;app&#39;&gt;&lt;&#x2F;span&gt;\n        &lt;input type&#x3D;&#39;text&#39; title&#x3D;&#39;&#39; id&#x3D;&#39;msg&#39;&gt;\n        &lt;button onclick&#x3D;&#39;sendMessage()&#39;&gt;发送&lt;&#x2F;button&gt;\n        &lt;button onclick&#x3D;&#39;stopWorker()&#39;&gt;stop!&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  \n    &lt;script type&#x3D;&#39;text&#x2F;javascript&#39;&gt;\n        if (typeof(Worker) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;)\t&#x2F;&#x2F; 使用Worker前检查一下浏览器是否支持\n        document.writeln(&#39; Sorry! No Web Worker support.. &#39;)\n        else &#123;\n            window.w &#x3D; new Worker(&#39;.&#x2F;work.js&#39;, &#123;name: &#39;w&#39;&#125;)\n            window.w.onmessage &#x3D; ev &#x3D;&gt; &#123;\n            document.getElementById(&#39;app&#39;).innerHTML &#x3D; ev.data\n        &#125;\n        \n        window.w.onerror &#x3D; err &#x3D;&gt; &#123;\n            w.terminate()\n            console.log(error.filename, error.lineno, error.message) &#x2F;&#x2F; 发生错误的文件名、行号、错误内容\n        &#125;\n        \n        function sendMessage() &#123;\n            const msg &#x3D; document.getElementById(&#39;msg&#39;)\n            window.w.postMessage(msg.value)\n        &#125;\n        \n        function stopWorker() &#123;\n            window.w.terminate()\n        &#125;\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>文件2：Work线程文件</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let i &#x3D; 1\n\nfunction simpleCount() &#123;\n  i++\n  self.postMessage(i)\n  setTimeout(simpleCount, 1000)\n&#125;\n\nsimpleCount()\n\nself.onmessage &#x3D; ev &#x3D;&gt; &#123;\n  postMessage(ev.data + &#39;测试接收&#39;)\n&#125;</code></pre>\n\n<p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API\">MDN - Web Workers 概念与用法</a><br><a href=\"https://link.zhihu.com/?target=http://www.ruanyifeng.com/blog/2018/07/web-worker.html\">阮一峰 - Web Worker 使用教程</a><br><a href=\"https://segmentfault.com/a/1190000014938305\">JavaScript 工作原理之七－Web Workers 分类及 5 个使用场景</a><br><a href=\"https://juejin.cn/post/6844903510673211400\">Web Worker在项目中的妙用</a><br><a href=\"https://juejin.cn/post/6844903590503383054\">怎么在 ES6+Webpack 下使用 Web Worker</a></p>\n<h3 id=\"8-HTML5的离线储存怎么使用，它的工作原理是什么？\"><a href=\"#8-HTML5的离线储存怎么使用，它的工作原理是什么？\" class=\"headerlink\" title=\"8. HTML5的离线储存怎么使用，它的工作原理是什么？\"></a>8. HTML5的离线储存怎么使用，它的工作原理是什么？</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\n<p>原理：HTML5的离线存储是基于一个新建的 <code>manifest</code> 文件，文件后缀名为 <code>.appcache</code> 的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; manifest&#x3D;&quot;demo.appcache&quot;&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>更多细节未作深入研究</p>\n<h3 id=\"9-iframe-有那些优点和缺点？\"><a href=\"#9-iframe-有那些优点和缺点？\" class=\"headerlink\" title=\"9. iframe 有那些优点和缺点？\"></a>9. iframe 有那些优点和缺点？</h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>\n<p>优点：</p>\n<ol>\n<li>因其的加载是和主页面异步的，所以可以加载复杂耗时的内容如广告等</li>\n<li>可以实现跨子域通信</li>\n<li>使脚本可以并行下载</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>iframe 会阻塞主页面的onload事件</li>\n<li>无法被一些搜索引擎识别</li>\n<li>会产生很多页面，不容易管理</li>\n</ol>\n<h3 id=\"10-title与h1-b与strong-i与em\"><a href=\"#10-title与h1-b与strong-i与em\" class=\"headerlink\" title=\"10. title与h1 b与strong i与em\"></a>10. title与h1 b与strong i与em</h3><p>title没有明确意义只是个标题，h1则是层次比较明确的标题</p>\n<p>strong有语义而b没有，搜索引擎更侧重于strong</p>\n<p>em有语义而i没有</p>\n<h3 id=\"11-label标签作用\"><a href=\"#11-label标签作用\" class=\"headerlink\" title=\"11. label标签作用\"></a>11. label标签作用</h3><p>label用来定义表单控件的关系，当用户选择label标签，浏览器会帮助用户自动聚焦和该label标签所关联的表单控件</p>\n<p>使用方式：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;label for&#x3D;&quot;mobile&quot;&gt;Number:&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;mobile&quot;&#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;label&gt;Date:&lt;input type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;&#x2F;label&gt;</code></pre>\n\n<h3 id=\"12-SVG和Canvas区别\"><a href=\"#12-SVG和Canvas区别\" class=\"headerlink\" title=\"12. SVG和Canvas区别\"></a>12. SVG和Canvas区别</h3><p>SVG是基于XML描述的2D图形语言，这意味着其中的每个图形都是可用的，都可以为其添加JS事件处理器，每个图形都被视为对象，如果SVG的对象属性发生变化，浏览器会自动重现图形。<br>特点：</p>\n<ul>\n<li>不依赖分辨率</li>\n<li>支持事件处理</li>\n<li>最适合带有大型渲染区域的应用程序（比如地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<p>Canvas是画布，基于JavaScript对其进行绘制的2D图形，是逐像素进行渲染的，位置发生改变时，就会重新渲染。<br>特点：</p>\n<ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理</li>\n<li>较弱的文本渲染能力</li>\n<li>能以.png或.jpg格式保存渲染的图像结果</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>\n</ul>\n<h3 id=\"13-head元素作用\"><a href=\"#13-head元素作用\" class=\"headerlink\" title=\"13. head元素作用\"></a>13. head元素作用</h3><p>用于定义文档的头部，是所有头部元素的容器。当中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。描述了文档各种属性和信息。</p>\n<p>其中可以包含base, link, meta, script, style, title，其中的title是唯一的必须的标签。</p>\n<h3 id=\"14-浏览器乱码的原因是什么？如何解决？\"><a href=\"#14-浏览器乱码的原因是什么？如何解决？\" class=\"headerlink\" title=\"14. 浏览器乱码的原因是什么？如何解决？\"></a>14. 浏览器乱码的原因是什么？如何解决？</h3><p>原因：</p>\n<ul>\n<li>网页原编码是<code>gbk</code>编码，如果内容中的中文是<code>utf-8</code>编码的话，浏览器打开时就会乱码，反之也会出现乱码</li>\n<li>从数据库调用的数据是<code>utf-8</code>编码，也会造成此情况</li>\n<li>浏览器不能自动检测网页编码，造成乱码</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>使用软件编辑HTML网页内容，保证编码一致</li>\n<li>如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进行程序转码</li>\n<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换</li>\n</ul>\n<h3 id=\"15-优雅降级和渐进增强的区别\"><a href=\"#15-优雅降级和渐进增强的区别\" class=\"headerlink\" title=\"15. 优雅降级和渐进增强的区别\"></a>15. 优雅降级和渐进增强的区别</h3><pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.transition&#123;\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;  \n&#125;\n.transition&#123; \n　　     transition: all .5s;\n　　  -o-transition: all .5s;\n  　-moz-transition: all .5s;\n -webkit-transition: all .5s;\n&#125;</code></pre>\n\n<p>优雅降级是以复杂现状为基础，试图减少用户体验的供给。优雅降级观点认为应该针对最先进、最高级的浏览器来设计，而将那些过时、老旧的浏览器版本放置于开发周期的最后阶段，在这种观点下，旧版浏览器被视为仅能提供“简陋却无妨”的浏览体验，可以做些小的调整来适应某个浏览器的特性，但由于他并不是我们关注的重点，因此除了修复较大的功能错误以外，其他差异将被直接忽略。</p>\n<p>渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要，渐进增强的观点是应该关注内容本身，因为不论浏览器收集、展示、寻求还是操作内容，其共同点是都涉及到内容。</p>\n<h3 id=\"16-HTML5-drag-API\"><a href=\"#16-HTML5-drag-API\" class=\"headerlink\" title=\"16. HTML5 drag API\"></a>16. HTML5 drag API</h3><ul>\n<li><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</p>\n</li>\n<li><p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</p>\n</li>\n<li><p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</p>\n</li>\n<li><p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>\n</li>\n<li><p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</p>\n</li>\n<li><p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</p>\n</li>\n<li><p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</p>\n</li>\n</ul>\n<p>示例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;style&gt;\n    #drop-area &#123;\n        width: 50px;\n        height: 50px;\n        background-color: yellow;\n    &#125;\n&lt;&#x2F;style&gt;\n\n&lt;div id&#x3D;&quot;drop-area&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;drag-el&quot; draggable&#x3D;&quot;true&quot;&gt;...&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    window.onload &#x3D; () &#x3D;&gt; &#123;\n        const dragEl &#x3D; document.querySelector(&#39;#drag-el&#39;)\n        const dropArea &#x3D; document.querySelector(&#39;#drop-area&#39;)\n\n        dragEl.addEventListener(&#39;dragstart&#39;, (event) &#x3D;&gt; &#123;\n            event.dataTransfer.setData(&#39;text&#x2F;plain&#39;, event.target.id);\n        &#125;)\n        dropArea.addEventListener(&#39;dragover&#39;, (event) &#x3D;&gt; &#123;\n            event.preventDefault();\n        &#125;)\n        dropArea.addEventListener(&#39;drop&#39;, (event) &#x3D;&gt; &#123;\n            const id &#x3D; event.dataTransfer.getData(&#39;text&#x2F;plain&#39;);\n            dropArea.appendChild(document.getElementById(id));\n        &#125;);\n    &#125;\n&lt;&#x2F;script&gt;</code></pre>","feature":true,"text":"1. src与href的区别src: 表示对资源的引用，它所指向的内容会被直接嵌入到当前标签所在的位置，例如图片、js脚本等。当浏览器解析到该元素时，会立刻停止其他资源的下载和处理，直到将该资源加载、编译、执行完毕，所以一般都会将js放在页面底部去处理。href: 表示超文本引用...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[{"name":"知识点","slug":"知识点","count":9,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试题","slug":"面试题","count":4,"path":"api/tags/面试题.json"},{"name":"HTML","slug":"HTML","count":1,"path":"api/tags/HTML.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1. src与href的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AF%AD%E4%B9%89%E5%8C%96\"><span class=\"toc-text\">2. 语义化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-DOCTYPE-%E2%BD%82%E6%A1%A3%E7%B1%BB%E5%9E%8B-%E7%9A%84%E4%BD%9C%E2%BD%A4\"><span class=\"toc-text\">3. DOCTYPE(⽂档类型) 的作⽤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-script%E6%A0%87%E7%AD%BE%E4%B8%ADdefer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4. script标签中defer和async的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-img%E7%9A%84srcset%E5%B1%9E%E6%80%A7%E5%92%8Csizes%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">5. img的srcset属性和sizes属性的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">6. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-web-work\"><span class=\"toc-text\">7. web work</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-HTML5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">8. HTML5的离线储存怎么使用，它的工作原理是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-iframe-%E6%9C%89%E9%82%A3%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">9. iframe 有那些优点和缺点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-title%E4%B8%8Eh1-b%E4%B8%8Estrong-i%E4%B8%8Eem\"><span class=\"toc-text\">10. title与h1 b与strong i与em</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-label%E6%A0%87%E7%AD%BE%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">11. label标签作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-SVG%E5%92%8CCanvas%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">12. SVG和Canvas区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-head%E5%85%83%E7%B4%A0%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">13. head元素作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\"><span class=\"toc-text\">14. 浏览器乱码的原因是什么？如何解决？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">15. 优雅降级和渐进增强的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-HTML5-drag-API\"><span class=\"toc-text\">16. HTML5 drag API</span></a></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端知识点之CSS汇总篇","uid":"59630f6cb50b5d1b95c17c1cbb07d624","slug":"前端知识点之CSS汇总篇/index","date":"2023-06-26T16:00:00.000Z","updated":"2023-07-09T06:47:42.700Z","comments":true,"path":"api/articles/前端知识点之CSS汇总篇/index.json","keywords":null,"cover":null,"text":"1. 布局技巧使用text-align-last对其两端文本 使用:not()选择器去除无用属性 多行文本溢出省略号 2. 事件技巧使用pointer-events禁用事件触发，场景：例如背景为地图，上层有图表的大屏看板 使用:hover描绘鼠标跟随 3. 面试题1. absol...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"知识点","slug":"知识点","count":9,"path":"api/categories/知识点.json"}],"tags":[{"name":"CSS","slug":"CSS","count":2,"path":"api/tags/CSS.json"},{"name":"面试题","slug":"面试题","count":4,"path":"api/tags/面试题.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Hexo搭建+配置GitHub Pages","uid":"b945a3fa38137babb32ce78c9f125574","slug":"Hexo搭建+配置GitHub Pages/index","date":"2023-04-05T16:00:00.000Z","updated":"2023-04-07T06:12:09.478Z","comments":false,"path":"api/articles/Hexo搭建+配置GitHub Pages/index.json","keywords":null,"cover":[],"text":"Hexo搭建+配置GitHub Pages1.0 搭建Hexo1.1 安装Node.js1.2 安装Git1.3 使用npm安装Hexo $ npm install -g hexo-cli &#x2F;&#x2F; hexo init [folder] $ hexo init B...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"环境搭建及配置","slug":"环境搭建及配置","count":4,"path":"api/categories/环境搭建及配置.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/tags/Hexo.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}