{"title":"Vue面试题","uid":"2180711b389bcc466bd851c9dffdefb1","slug":"Vue面试题/index","date":"2022-09-02T16:00:00.000Z","updated":"2023-07-27T08:19:09.222Z","comments":true,"path":"api/articles/Vue面试题/index.json","keywords":null,"cover":null,"content":"<h3 id=\"一、什么是单页面应用，有什么优缺点？\"><a href=\"#一、什么是单页面应用，有什么优缺点？\" class=\"headerlink\" title=\"一、什么是单页面应用，有什么优缺点？\"></a>一、什么是单页面应用，有什么优缺点？</h3><p>单页面应用仅在Web页面初始化时就加载相应的HTML、JS、CSS，加载完成后，不会随着用户操作而进行页面的跳转或重新加载，而是用路由机制实现HTML内容的转换，避免页面的重新加载。</p>\n<p>优点：</p>\n<ol>\n<li>首次加载结束后，后续的用户体验好，操作快，避免了重复渲染</li>\n<li>对服务器压力小</li>\n<li>前后端职责分离，前端负责交互逻辑，后端负责数据处理</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>首次加载耗时多</li>\n<li>因为使用了路由替代页面的跳转和重新加载，所以不能使用浏览器的前进后退功能，页面切换需要自己建立对战管理</li>\n<li>SEO难度大，因为所有内容都在一个页面中动态展示，SEO有天然劣势</li>\n</ol>\n<h3 id=\"二、v-show与v-if\"><a href=\"#二、v-show与v-if\" class=\"headerlink\" title=\"二、v-show与v-if\"></a>二、v-show与v-if</h3><p>v-if 是条件渲染，能确保切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，同时也是<strong>惰性</strong>的，如果初始条件为false，则什么都不做，直到第一次变为true，才会渲染该条件块</p>\n<p>v-show 不管初始条件，都会被渲染，只是简单的使用CSS的<code>display</code>属性进行切换</p>\n<p>所以，对比来看v-show更适合频繁切换的场景，而v-if适合渲染后条件很少改变的情况</p>\n<h3 id=\"三、Vue的单向数据流\"><a href=\"#三、Vue的单向数据流\" class=\"headerlink\" title=\"三、Vue的单向数据流\"></a>三、Vue的单向数据流</h3><p>父组件通过子组件的<code>prop</code>属性，实现了单向下行绑定，父级的属性更新会通过它传递向子组件中，但是反过来子组件不能修改<code>prop</code>属性值，来保证数据的单向流转，子组件想要改变父组件的值时，只能通过<code>$emit</code>来抛出一个事件，父组件接收该事件，然后做出相应的改变。</p>\n<h3 id=\"四、watch和computed\"><a href=\"#四、watch和computed\" class=\"headerlink\" title=\"四、watch和computed\"></a>四、watch和computed</h3><p>computed: 是计算属性，并且值有缓存，只有它以来的属性值发生改变，<strong>下一次</strong>获取才会重新计算computed的值，如果用不到该值时，则不会处理该逻辑</p>\n<p>watch: 是监听，数据变化时会执行回调进行后续操作</p>\n<h3 id=\"五、直接给一个数组项赋值，Vue会检测的变化吗？\"><a href=\"#五、直接给一个数组项赋值，Vue会检测的变化吗？\" class=\"headerlink\" title=\"五、直接给一个数组项赋值，Vue会检测的变化吗？\"></a>五、直接给一个数组项赋值，Vue会检测的变化吗？</h3><p>Vue2不会监听到如下操作：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">vm.items[index] &#x3D; newValue;\nvm.items.length &#x3D; newLength;</code></pre>\n\n<p>可以通过如下方式解决：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">vm.$set(vm.itmes, index, newValue);\nvm.items.splice(index, 1, newValue);\n\nvm.items.splice(newLength);</code></pre>\n\n<p>具体原因参考：<br><a href=\"https://meng160626.github.io/post/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2Findex\">Vue双向绑定</a></p>\n<h3 id=\"六、Vue2生命周期\"><a href=\"#六、Vue2生命周期\" class=\"headerlink\" title=\"六、Vue2生命周期\"></a>六、Vue2生命周期</h3><p><code>beforeCreate</code>: 刚初始化了一个Vue空的实例对象，该对象此时只有默认的生命周期和默认事件，其他东西都未创建</p>\n<p><code>created</code>: data和methods都已经初始化好了</p>\n<p><code>beforeMount</code>: 模板已经编译好了，但还未挂载到页面中，此时，页面还是旧的</p>\n<p><code>mouted</code>: 整个Vue实例都已经初始化完毕，结束创建阶段，进入运行阶段，可以访问Dom节点</p>\n<p><code>beforeUpdate</code>: 页面中的显示数据还是旧的，但data数据已更新，此时的页面未和数据保持同步</p>\n<p><code>updated</code>: 页面已经和数据同步</p>\n<p><code>beforeDestroy</code>: Vue实例从运行阶段进入销毁阶段，执行时该回调时，所有内容都依旧处于可用状态</p>\n<p><code>destroyed</code>: 所有内容已不可用</p>\n<h3 id=\"七、父子组件生命周期顺序\"><a href=\"#七、父子组件生命周期顺序\" class=\"headerlink\" title=\"七、父子组件生命周期顺序\"></a>七、父子组件生命周期顺序</h3><p>渲染时:<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>\n<p>子组件更新:<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>\n<p>父组件更新:<br>父 beforeUpdate -&gt; 父 updated</p>\n<p>销毁时:<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>\n<h3 id=\"八、在哪个生命周期调用异步请求更合理？\"><a href=\"#八、在哪个生命周期调用异步请求更合理？\" class=\"headerlink\" title=\"八、在哪个生命周期调用异步请求更合理？\"></a>八、在哪个生命周期调用异步请求更合理？</h3><p><code>created</code>、<code>beforeMount</code>、<code>mouted</code>，因为此时data已经创建，可以直接将返回数据赋值，但更推荐在<code>created</code>，因为可以更快获取到服务器数据，减少页面loading时间，并且ssr不支持<code>beforeMount</code>、<code>mounted</code>钩子，所以放在<code>created</code>中有助于一致性</p>\n<h3 id=\"九、父组件监听子组件的生命周期\"><a href=\"#九、父组件监听子组件的生命周期\" class=\"headerlink\" title=\"九、父组件监听子组件的生命周期\"></a>九、父组件监听子组件的生命周期</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;  Parent.vue\n&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot; &gt;&lt;&#x2F;Child&gt;\n\ndoSomething() &#123;\n   console.log(&#39;父组件监听到 mounted 钩子函数 ...&#39;);  &#x2F;&#x2F; 后触发\n&#125;,\n\n&#x2F;&#x2F;  Child.vue\nmounted()&#123;\n   console.log(&#39;子组件触发 mounted 钩子函数 ...&#39;);  &#x2F;&#x2F; 先触发\n&#125;,   </code></pre>\n\n<h3 id=\"十、组件中的data为什么是一个函数？\"><a href=\"#十、组件中的data为什么是一个函数？\" class=\"headerlink\" title=\"十、组件中的data为什么是一个函数？\"></a>十、组件中的data为什么是一个函数？</h3><p>因为要隔离作用域，否则组件中的data值会相互影响，如果是一个函数，利用闭包原理，可以维护每一个对象的隔离性。</p>\n<h3 id=\"十一、v-model原理\"><a href=\"#十一、v-model原理\" class=\"headerlink\" title=\"十一、v-model原理\"></a>十一、v-model原理</h3><p>实际就是替我们绑定了表单控件事件和value值的语法糖，如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;input v-model&#x3D;&#39;something&#39;&gt;\n\n&lt;!-- 相当于 --&gt;\n\n&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</code></pre>\n\n<h3 id=\"十二、Vue组件通信方式\"><a href=\"#十二、Vue组件通信方式\" class=\"headerlink\" title=\"十二、Vue组件通信方式\"></a>十二、Vue组件通信方式</h3><ol>\n<li>props &#x2F; $emit 父子组件通信</li>\n<li>ref &#x2F; $parent &#x2F; $children 父子组件通信</li>\n<li>EventBus($emit &#x2F; $on) 任何</li>\n<li>provide &#x2F; inject 隔代组件</li>\n<li>Vuex 任何</li>\n<li>$attrs &#x2F; $listeners 隔代</li>\n</ol>\n<h3 id=\"十三、vue-router-路由模式有几种？\"><a href=\"#十三、vue-router-路由模式有几种？\" class=\"headerlink\" title=\"十三、vue-router 路由模式有几种？\"></a>十三、vue-router 路由模式有几种？</h3><ol>\n<li>hash</li>\n<li>history</li>\n<li>abstract</li>\n</ol>\n<h3 id=\"十四、hash模式和history模式的原理和区别？\"><a href=\"#十四、hash模式和history模式的原理和区别？\" class=\"headerlink\" title=\"十四、hash模式和history模式的原理和区别？\"></a>十四、hash模式和history模式的原理和区别？</h3><ul>\n<li>hash模式</li>\n</ul>\n<p>其原理是通过url中的hash值来实现客户端状态的变更，也就是利用<code>location.hash</code>的值，通过监听浏览器<code>hashchange</code>事件变化，去查找对应路由应用。</p>\n<ul>\n<li>history模式</li>\n</ul>\n<p>利用html5中新增的<code>pushState()</code>和<code>replaceState()</code>方法，改变页面路径。</p>\n<p>区别：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>hash会在url中带#，history更优雅</li>\n<li>history可以跳转同源任意url，而hash只能跳转同文档的url</li>\n<li>pushState可以记录任意类型数据，而hash只能添加短字符串</li>\n<li>hash兼容IE8以上，而history只兼容IE10以上</li>\n<li>history需要后端配合将所有访问都指向index.html，否则用户刷新页面，会导致404错误</li>\n</ol></blockquote>\n<h3 id=\"十五、虚拟DOM的优缺点\"><a href=\"#十五、虚拟DOM的优缺点\" class=\"headerlink\" title=\"十五、虚拟DOM的优缺点\"></a>十五、虚拟DOM的优缺点</h3><p>优点：</p>\n<ul>\n<li>保证性能下限</li>\n</ul>\n<p>在不手动优化的情况下，依然能提供不错的性能</p>\n<ul>\n<li>无需手动操作DOM</li>\n</ul>\n<p>只需要写好View-Model层的代码逻辑，框架根据虚拟DOM和数据双向绑定，帮助我们以预期方式更新视图，提高开发效率</p>\n<ul>\n<li>跨平台</li>\n</ul>\n<p>虚拟DOM本质上是JS对象，而DOM和平台强相关，所以虚拟DOM能更方便的跨平台操作</p>\n<h3 id=\"十六、虚拟DOM实现原理？\"><a href=\"#十六、虚拟DOM实现原理？\" class=\"headerlink\" title=\"十六、虚拟DOM实现原理？\"></a>十六、虚拟DOM实现原理？</h3><ol>\n<li>用JS对象模拟真实DOM树，对其进行抽象</li>\n<li><code>diff</code>算法 —— 比较两棵树差异</li>\n<li><code>pach</code>算法 —— 将两个虚拟DOM对象的差异应用到真正的DOM树</li>\n</ol>\n<h3 id=\"十七、Vue中的key有什么作用？\"><a href=\"#十七、Vue中的key有什么作用？\" class=\"headerlink\" title=\"十七、Vue中的key有什么作用？\"></a>十七、Vue中的key有什么作用？</h3><p>key作为Vue中vnode的唯一标记，通过这个key，能让diff操作更准确，更快速。</p>\n","text":"一、什么是单页面应用，有什么优缺点？单页面应用仅在Web页面初始化时就加载相应的HTML、JS、CSS，加载完成后，不会随着用户操作而进行页面的跳转或重新加载，而是用路由机制实现HTML内容的转换，避免页面的重新加载。 优点： 首次加载结束后，后续的用户体验好，操作快，避免了重复...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"知识点","slug":"知识点","count":12,"path":"api/categories/知识点.json"}],"tags":[{"name":"Vue","slug":"Vue","count":3,"path":"api/tags/Vue.json"},{"name":"面试题","slug":"面试题","count":6,"path":"api/tags/面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">一、什么是单页面应用，有什么优缺点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81v-show%E4%B8%8Ev-if\"><span class=\"toc-text\">二、v-show与v-if</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">三、Vue的单向数据流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81watch%E5%92%8Ccomputed\"><span class=\"toc-text\">四、watch和computed</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue%E4%BC%9A%E6%A3%80%E6%B5%8B%E7%9A%84%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">五、直接给一个数组项赋值，Vue会检测的变化吗？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81Vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">六、Vue2生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">七、父子组件生命周期顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%9B%B4%E5%90%88%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">八、在哪个生命周期调用异步请求更合理？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">九、父组件监听子组件的生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F\"><span class=\"toc-text\">十、组件中的data为什么是一个函数？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81v-model%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">十一、v-model原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">十二、Vue组件通信方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%89%E3%80%81vue-router-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F\"><span class=\"toc-text\">十三、vue-router 路由模式有几种？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%9B%9B%E3%80%81hash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">十四、hash模式和history模式的原理和区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%94%E3%80%81%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">十五、虚拟DOM的优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%85%AD%E3%80%81%E8%99%9A%E6%8B%9FDOM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">十六、虚拟DOM实现原理？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%83%E3%80%81Vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">十七、Vue中的key有什么作用？</span></a></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"小程序嵌入Echarts","uid":"22dc96c39bfd9211e7d5443bdb3c36d8","slug":"小程序嵌入Echarts/index","date":"2022-10-07T16:00:00.000Z","updated":"2023-04-07T03:55:10.069Z","comments":false,"path":"api/articles/小程序嵌入Echarts/index.json","keywords":null,"cover":null,"text":"1. 构建组件嵌入Echarts新建一个文件夹ec-canvas，用于专门放置echarts相关文件，并创建同名的组件 前往echarts官网制定自定义主题（因微信小程序大小限制，选择项目中需要用到的即可，尽量减少文件大小），之后将打包好的echarts.js文件放到上述创建好的...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"小程序","slug":"小程序","count":1,"path":"api/categories/小程序.json"}],"tags":[{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"},{"name":"Echarts","slug":"Echarts","count":1,"path":"api/tags/Echarts.json"},{"name":"组件引入","slug":"组件引入","count":1,"path":"api/tags/组件引入.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"uni-app开发小程序 bug记录","uid":"d2b1c86d84778284c9a48f05cbcb4fb9","slug":"uni-app开发小程序-bug记录/index","date":"2022-08-22T16:00:00.000Z","updated":"2023-04-06T05:59:01.677Z","comments":true,"path":"api/articles/uni-app开发小程序-bug记录/index.json","keywords":null,"cover":[],"text":"使用uView组件u-datetime-picker组件渲染失效 使用该组件时，如果以任何方式配置cancel事件，会导致组件渲染失败需要如下添加两条属性，并且值不能为官方默认值，否则依旧会渲染失败 无法穿透至组件内部修改样式 需要在methods同级位置添加代码 options...","link":"","photos":[],"count_time":{"symbolsCount":318,"symbolsTime":"1 mins."},"categories":[{"name":"bug","slug":"bug","count":6,"path":"api/categories/bug.json"}],"tags":[{"name":"bug","slug":"bug","count":6,"path":"api/tags/bug.json"},{"name":"uni-app","slug":"uni-app","count":2,"path":"api/tags/uni-app.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}