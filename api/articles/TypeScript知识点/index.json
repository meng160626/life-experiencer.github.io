{"title":"TypeScript","uid":"0aaa27c48e7b40c2bc96b31fb70803da","slug":"TypeScript知识点/index","date":"2023-07-29T16:00:00.000Z","updated":"2023-07-31T10:03:36.033Z","comments":true,"path":"api/articles/TypeScript知识点/index.json","keywords":null,"cover":null,"content":"<h2 id=\"一、TS-基础概念\"><a href=\"#一、TS-基础概念\" class=\"headerlink\" title=\"一、TS 基础概念\"></a>一、TS 基础概念</h2><h3 id=\"1-什么是TS\"><a href=\"#1-什么是TS\" class=\"headerlink\" title=\"1. 什么是TS\"></a>1. 什么是TS</h3><p>a. JS的一个超集，在原有基础上添加了可选静态类型，基于类的面向对象编程</p>\n<ol>\n<li>编写项目 - 更利于架构维护</li>\n<li>自主检测 - 编译期间检测</li>\n<li>类型检测 - 支持了动态和静态类型检测 &#x3D;&gt; 本质上存在类型转换</li>\n<li>运行流程 - 依赖编译</li>\n<li>复杂特性 - 模块化、泛型、接口</li>\n</ol>\n<h3 id=\"2-TS基本类型和写法\"><a href=\"#2-TS基本类型和写法\" class=\"headerlink\" title=\"2. TS基本类型和写法\"></a>2. TS基本类型和写法</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let isEnabled: boolean &#x3D; true;\nlet class: string &#x3D; &#39;ts&#39;;\nlet classNum: number &#x3D; 2;\nlet classArr: string[] &#x3D; [&#39;basic&#39;];\nlet classArr: Array&lt;string&gt; &#x3D; [&#39;basic&#39;];</code></pre>\n\n<ul>\n<li>tuple - 元组</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let tupleType: [string, boolean];\ntupleType &#x3D; [&#39;ts&#39;, true];</code></pre>\n\n<ul>\n<li>enum - 枚举</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 数字类枚举 - 默认从零开始，依次递增\nenum Score &#123;\n    BAD,\n    NG,\n    GOOD,\n    PERFECT\n&#125;\nlet score: Score &#x3D; Score.BAD;\n\n&#x2F;&#x2F; 字符串类枚举\nenum Score &#123;\n    BAD &#x3D; &#39;BAD&#39;,\n    NG &#x3D; &#39;NG&#39;,\n    GOOD &#x3D; &#39;GOOD&#39;,\n    PERFECT &#x3D; &#39;PERFECT&#39;\n&#125;\n\n&#x2F;&#x2F; 反向映射 - 只有在数字类枚举时可以进行\nenum Score &#123;\n    BAD,\n    NG,\n    GOOD,\n    PERFECT\n&#125;\n\nlet scoreName &#x3D; Score[0];       &#x2F;&#x2F; &#39;BAD&#39;\nlet scoreValue &#x3D; Score[&#39;BAD&#39;];  &#x2F;&#x2F; 0\n\n&#x2F;&#x2F; 异构\nenum Score &#123;\n    A,\n    B,\n    C &#x3D; &#39;C&#39;,\n    D &#x3D; 5,\n    E,\n    F\n&#125;\nScore.E &#x3D;&#x3D;&#x3D; 6;    &#x2F;&#x2F; true</code></pre>\n\n<ul>\n<li>any unknown void never</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; any - 绕过所有检查 &#x3D;&gt; 类型检测和编译筛查全部失效\nlet value: any &#x3D; 123;\nvalue &#x3D; &#39;any&#39;;  &#x2F;&#x2F; ok\n\n&#x2F;&#x2F; unknown - 绕过赋值检查 &#x3D;&gt; 禁止更改传递\nlet unknownV: unknown;\nunknownV &#x3D; &#39;unknownValue&#39;;\n\nlet value1: unknown &#x3D; unknownV;     &#x2F;&#x2F; ok\nlet value2: any &#x3D; unknownV;     &#x2F;&#x2F; ok\nlet value3: boolean &#x3D; unknownV;     &#x2F;&#x2F; N ok\n\n&#x2F;&#x2F; void - 声明函数返回值\nfunction voidFunction(): void &#123;\n    console.log(&#39;no return&#39;);\n&#125;\n\n&#x2F;&#x2F; never - 永不返回\nfunction error(msg: string): never &#123;\n    throw new Error(msg);\n&#125;;\nfunction longlongloop(): never &#123;\n    while(true) &#123;&#125;\n&#125;</code></pre>\n\n<h3 id=\"二、接口\"><a href=\"#二、接口\" class=\"headerlink\" title=\"二、接口\"></a>二、接口</h3><ul>\n<li>对行为的抽象，具体行为由类实现</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface People &#123;\n    name: string;\n    age: number;\n&#125;\nlet people: People &#x3D; &#123;\n    name: &#39;张三&#39;,\n    age: 1\n&#125;\n\n&#x2F;&#x2F; 只读属性\ninterface People &#123;\n    readonly name: string;\n    age: number;\n&#125;\n&#x2F;&#x2F; 任意属性\ninterface People &#123;\n    name: string;\n    age: number;\n    [propName: string]: any;\n&#125;\n\n&#x2F;&#x2F; 和JS的引用不同\nlet arr: ReadonlyArray&lt;number&gt; &#x3D; [1, 2, 3];\n\narr[0] &#x3D; 2;     &#x2F;&#x2F; Error\narr.push(4);    &#x2F;&#x2F; Error\narr.length &#x3D; 4; &#x2F;&#x2F; Error\narr &#x3D; [1,2,3];  &#x2F;&#x2F; Error</code></pre>\n\n<h3 id=\"三、交叉类型\"><a href=\"#三、交叉类型\" class=\"headerlink\" title=\"三、交叉类型\"></a>三、交叉类型</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 合并\ninterface A &#123; x: C &#125;;\ninterface B &#123; x: D &#125;;\n\ninterface C &#123; e: string &#125;;\ninterface D &#123; f: boolean &#125;;\n\ntype AB &#x3D; A &amp; B;\n\nlet ab: AB &#x3D; &#123;\n    x: &#123;\n        e: &#39;...&#39;,\n        f: true\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 合并冲突\ninterface A &#123; x: string &#125;;\ninterface B &#123; x: number &#125;;\ntype AB &#x3D; A &amp; B;\n&#x2F;&#x2F; 因为没有一种类型既是string又是number，所以 x: never</code></pre>\n\n<h3 id=\"四、断言-类型声明、转换\"><a href=\"#四、断言-类型声明、转换\" class=\"headerlink\" title=\"四、断言 - 类型声明、转换\"></a>四、断言 - 类型声明、转换</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 尖括号\nlet anyV: any &#x3D; &#39;ts&#39;;\nlet anyVLength: number &#x3D; (&lt;string&gt;anyV).length;     &#x2F;&#x2F; 阶段性声明\n\n&#x2F;&#x2F; as声明\nlet anyVLength: number &#x3D; (anyV as string).length;\n\n&#x2F;&#x2F; 非空判断\ntype ClassTime &#x3D; () &#x3D;&gt; number;\nconst start &#x3D; (classTime: ClassTime | undefined) &#x3D;&gt; &#123;\n    let num &#x3D; classTime!();\n&#125;\n\n&#x2F;&#x2F; 面试题\nconst tsClass: number | undefined &#x3D; undefined;\nconst course: number &#x3D; tsClass!;    &#x2F;&#x2F; 忽略空值传入\n&#x2F;&#x2F; 使用的意义 &#x3D;&gt; 告知编译器，运行时下会被赋值</code></pre>\n\n<h3 id=\"五、类型守卫\"><a href=\"#五、类型守卫\" class=\"headerlink\" title=\"五、类型守卫\"></a>五、类型守卫</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Teacher &#123;\n    name: string;\n    courses: string[];\n&#125;\ninterface Student &#123;\n    name: string;\n    startTime: Date;\n&#125;\ntype Class &#x3D; Teacher | Student;\nfunction startCourse(cls: Class) &#123;\n    if (&#39;courses&#39; in cls) &#123; &#x2F;&#x2F; cls instanceof Teacher\n        &#x2F;&#x2F; teacher逻辑\n    &#125;\n    if (&#39;startTime&#39; in cls) &#123;\n        &#x2F;&#x2F; student逻辑\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"六、TS进阶\"><a href=\"#六、TS进阶\" class=\"headerlink\" title=\"六、TS进阶\"></a>六、TS进阶</h3><h4 id=\"1-泛型-重用\"><a href=\"#1-泛型-重用\" class=\"headerlink\" title=\"1. 泛型 - 重用\"></a>1. 泛型 - 重用</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function demo&lt;T, U&gt;(name: T, age: U): T &#123;\n    return name + age;\n&#125;\nconsole.log(demo&lt;string, number&gt;(&#39;yy&#39;, 6));</code></pre>\n\n<h4 id=\"2-装饰器-decorator\"><a href=\"#2-装饰器-decorator\" class=\"headerlink\" title=\"2. 装饰器 - decorator\"></a>2. 装饰器 - decorator</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 类装饰器\nfunction Dec(target: Function): void &#123;\n    target.prototype.test &#x3D; function(): void &#123;\n        &#x2F;&#x2F; test函数逻辑\n    &#125;\n&#125;\n\n@Dec\nclass Demo &#123;\n    constructor() &#123;\n        &#x2F;&#x2F; 业务逻辑\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 属性装饰器\nfunction nameWrapper(target: any, key: string) &#123;\n\n    &#x2F;&#x2F; 逻辑处理\n    Object.defineProperty(target, key, &#123;\n        &#x2F;&#x2F; 劫持\n    &#125;);\n&#125;\nclass People &#123;\n    constructor() &#123;\n\n    &#125;\n\n    @nameWrapper\n    public name: string;\n&#125;\n\n&#x2F;&#x2F; 方法装饰器\nfunction funcDec(target: any, funcName: string, operation: PropertyDescriptor) &#123;\n\n&#125;\nclass People &#123;\n    constructor() &#123;\n\n    &#125;\n\n    @funcDec\n    test() &#123;\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-原理解析\"><a href=\"#3-原理解析\" class=\"headerlink\" title=\"3. 原理解析\"></a>3. 原理解析</h4><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 1. 源码输入\nlet a: number &#x3D; 2;\n\n&#x2F;&#x2F; 2. scanner 扫描器扫描 &#x3D;&gt; 识别内容范围生成数据流\n[\n    &quot;let&quot;: &quot;keyword&quot;,\n    &quot;a&quot;: &quot;identifier&quot;,\n    &quot;&#x3D;&quot;: &quot;assignment&quot;,\n    &quot;2&quot;: &quot;integer&quot;,\n    &quot;;&quot;: &quot;eos&quot;(end of statement)\n]\n&#x2F;&#x2F; number 用来做校验\n\n&#x2F;&#x2F; 3. 解析器 parser 生成语法树 - AST\n&#123;\n    operation: &quot;&#x3D;&quot;,\n    left: &#123;\n        keyword: &#39;var&#39;,\n        ...\n    &#125;,\n    ...\n&#125;\n\n&#x2F;&#x2F; 4. 绑定器 binder 主要职责 创建symbols\n&#x2F;&#x2F; node.symbol\n\n&#x2F;&#x2F; 5. 校验器 checker 检查TS语法错误 &#x3D;&gt; 检查器中进行的\n\n&#x2F;&#x2F; 6. 发射器 emitter 根据每个节点的的检查结果产出node翻译成js</code></pre>","feature":true,"text":"一、TS 基础概念1. 什么是TSa. JS的一个超集，在原有基础上添加了可选静态类型，基于类的面向对象编程 编写项目 - 更利于架构维护 自主检测 - 编译期间检测 类型检测 - 支持了动态和静态类型检测 &#x3D;&gt; 本质上存在类型转换 运行流程 - 依赖编译 复杂特...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"知识点","slug":"知识点","count":12,"path":"api/categories/知识点.json"}],"tags":[{"name":"TS","slug":"TS","count":1,"path":"api/tags/TS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81TS-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">一、TS 基础概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFTS\"><span class=\"toc-text\">1. 什么是TS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-TS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%86%99%E6%B3%95\"><span class=\"toc-text\">2. TS基本类型和写法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">二、接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">三、交叉类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%96%AD%E8%A8%80-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E3%80%81%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">四、断言 - 类型声明、转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB\"><span class=\"toc-text\">五、类型守卫</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81TS%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">六、TS进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%B3%9B%E5%9E%8B-%E9%87%8D%E7%94%A8\"><span class=\"toc-text\">1. 泛型 - 重用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%A3%85%E9%A5%B0%E5%99%A8-decorator\"><span class=\"toc-text\">2. 装饰器 - decorator</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">3. 原理解析</span></a></li></ol></li></ol></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"函数式编程","uid":"78bf35c97e41da6a2bdad05b63951aa3","slug":"函数式编程/index","date":"2023-07-23T16:00:00.000Z","updated":"2023-07-25T10:23:31.148Z","comments":true,"path":"api/articles/函数式编程/index.json","keywords":null,"cover":null,"text":"一、函数式编程特点1. 原理 加法结合律 | 因式分解 | 完全平方公式 &#x3D;&gt; 原子组合进行变化 a + b + c &#x3D; (a + b) + c 2. 理论思想 函数是一等公民 &#x3D;&gt; 将函数视为实际功能逻辑的落脚点 &#x3D;&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"效率优化","slug":"效率优化","count":5,"path":"api/categories/效率优化.json"}],"tags":[{"name":"JS","slug":"JS","count":4,"path":"api/tags/JS.json"},{"name":"函数式编程","slug":"函数式编程","count":1,"path":"api/tags/函数式编程.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}