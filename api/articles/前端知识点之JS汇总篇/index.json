{"title":"前端知识点之JS汇总篇","uid":"c99a5fe4a5656caa27d2f9936274bd86","slug":"前端知识点之JS汇总篇/index","date":"2023-07-01T16:00:00.000Z","updated":"2023-07-03T04:30:02.140Z","comments":true,"path":"api/articles/前端知识点之JS汇总篇/index.json","keywords":null,"cover":null,"content":"<h3 id=\"1-作用域-上下文\"><a href=\"#1-作用域-上下文\" class=\"headerlink\" title=\"1. 作用域 + 上下文\"></a>1. 作用域 + 上下文</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">    console.log(&#39;a&#39;);\n    console.log(c);\n    console.log(d);\n\n    let c &#x3D; &#39;c&#39;;\n    var d &#x3D; &#39;d&#39;;\n    demo();\n    function demo() &#123;\n        console.log(&#39;b&#39;);\n&#125;</code></pre>\n<p>这里的<code>demo</code>可以正常执行是函数提升，在同作用域内，执行在声明之前可以正常执行，但超出作用于的提前使用无效<br>变量<code>c</code>打印会报错<strong>c is not defined</strong>，但d会打印，结果显示为<code>undefined</code>，是因为用var声明变量可以进行变量声明提升（提升声明，但不能提升赋值）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(demo);      &#x2F;&#x2F; ƒ demo() &#123;console.log(1);&#125;\nfunction demo() &#123;\n    console.log(1);\n&#125; \ndemo &#x3D; &#39;demo&#39;;\nconsole.log(demo);      &#x2F;&#x2F; demo</code></pre>\n\n<p>提升优先级 <strong>变量优先</strong>：会优先显示函数，因为先声明了变量，然后函数对同名变量进行了赋值，走到变量赋值的语句后，又对变量进行了覆盖，最后打印出来会是变量</p>\n<h3 id=\"2-this-上下文context\"><a href=\"#2-this-上下文context\" class=\"headerlink\" title=\"2. this 上下文context\"></a>2. this 上下文context</h3><p>this是在执行时动态读取上下文决定的，而不是创建时</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fn() &#123;\n    console.log(this);  &#x2F;&#x2F; window\n&#125;\nfn();</code></pre>\n<p>this指向函数的调用者也就是window</p>\n<h4 id=\"隐式绑定-——-this指代调用堆栈的上一级-x3D-gt-对象、数组等引用关系逻辑\"><a href=\"#隐式绑定-——-this指代调用堆栈的上一级-x3D-gt-对象、数组等引用关系逻辑\" class=\"headerlink\" title=\"隐式绑定 —— this指代调用堆栈的上一级 &#x3D;&gt; 对象、数组等引用关系逻辑\"></a>隐式绑定 —— this指代调用堆栈的上一级 &#x3D;&gt; 对象、数组等引用关系逻辑</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fn() &#123;\n    console.log(this.a);\n&#125;\nconst obj &#x3D; &#123;\n    a: 1,\n    fn\n&#125;\nobj.fn();           &#x2F;&#x2F; 1</code></pre>\n\n<h4 id=\"显示绑定-bind-apply-call\"><a href=\"#显示绑定-bind-apply-call\" class=\"headerlink\" title=\"显示绑定 (bind | apply | call)\"></a>显示绑定 (bind | apply | call)</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fn() &#123;\n    console.log(this);\n&#125;\n\nfn.call(&#123;\n    a: 1\n&#125;);\n\nfn.apply(&#123;\n    a: 1\n&#125;);\n\nconst bindFn &#x3D; fn.bind(&#123;\n    a: 1\n&#125;);\nbindFn();</code></pre>\n\n<h4 id=\"面试题-call、apply、bind的区别\"><a href=\"#面试题-call、apply、bind的区别\" class=\"headerlink\" title=\"面试题 call、apply、bind的区别\"></a>面试题 call、apply、bind的区别</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function demo(arg1, arg2) &#123;\n    return [arg1, arg2];\n&#125;\n\ndemo.call(1, 2);\ndemo.apply([1, 2]);\nconst tempFn &#x3D; demo.bind(this, 1, 2);\ntempFn();</code></pre>\n\n<ul>\n<li>call和apply都是以当前上下文(作用域)直接执行该函数，但区别是传参方式，call是依次传入&#x2F;apply是数组传入</li>\n<li>bind则是传入一个上下文环境(作用域)，返回一个待执行函数，需要再次调用该函数来得到结果</li>\n</ul>\n<h4 id=\"手写题-实现一个bind\"><a href=\"#手写题-实现一个bind\" class=\"headerlink\" title=\"手写题 实现一个bind\"></a>手写题 实现一个bind</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 1. bind函数所处的位置 &#x3D;&gt; Function.prototype\nFunction.prototype.myBind &#x3D; function() &#123;\n    &#x2F;&#x2F; 2. 接收新的作用域和参数\n    const args &#x3D; Array.prototype.slice.call(arguments);\n    const newThis &#x3D; args.shift() || window;\n    &#x2F;&#x2F; 3. 将函数挂载在新的作用域上\n    newThis.tempFn &#x3D; this;\n    &#x2F;&#x2F; 4. 返回待执行函数\n    return function() &#123;\n        &#x2F;&#x2F; 5. 执行后需要清空内存\n        const result &#x3D; args[0] ? newThis.tempFn(...args) : newThis.tempFn();\n        delete newThis.tempFn;\n        return result;\n    &#125;\n&#125;\n\nfunction demo() &#123;\n    return this.a;\n&#125;\n\nconsole.log(demo.myBind(&#123;\n    a: 1\n&#125;)());</code></pre>\n\n<h3 id=\"3-闭包\"><a href=\"#3-闭包\" class=\"headerlink\" title=\"3. 闭包\"></a>3. 闭包</h3><p>闭包: 一个函数和他周围环境状态捆绑在一起的组合</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 函数作为返回值的场景\nfunction demo() &#123;\n    let content &#x3D; &#39;内容&#39;;\n    return function() &#123;\n        return content;\n    &#125;\n&#125;\nconst temp &#x3D; demo;\ntemp();                     &#x2F;&#x2F; 内容\n\n&#x2F;&#x2F; 函数作为参数的时候\nlet content &#x3D; 1;\nfunction demo(fn) &#123;\n    let content &#x3D; 2;\n    fn();\n&#125;\nfunction test() &#123;\n    console.log(content);\n&#125;\ntest();                     &#x2F;&#x2F; 1\ndemo(test);                 &#x2F;&#x2F; 1\n&#x2F;&#x2F; 这里的test形成了window的闭包函数，也是因为content在demo内部，作用域无法作用到声明在window中的test函数</code></pre>","feature":true,"text":"1. 作用域 + 上下文 console.log(&#39;a&#39;); console.log(c); console.log(d); let c &#x3D; &#39;c&#39;; var d &#x3D; &#39;d&#39;; demo(); function ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"知识点","slug":"知识点","count":9,"path":"api/categories/知识点.json"}],"tags":[{"name":"面试题","slug":"面试题","count":4,"path":"api/tags/面试题.json"},{"name":"JS","slug":"JS","count":1,"path":"api/tags/JS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">1. 作用域 + 上下文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-this-%E4%B8%8A%E4%B8%8B%E6%96%87context\"><span class=\"toc-text\">2. this 上下文context</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A-%E2%80%94%E2%80%94-this%E6%8C%87%E4%BB%A3%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E7%9A%84%E4%B8%8A%E4%B8%80%E7%BA%A7-x3D-gt-%E5%AF%B9%E8%B1%A1%E3%80%81%E6%95%B0%E7%BB%84%E7%AD%89%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">隐式绑定 —— this指代调用堆栈的上一级 &#x3D;&gt; 对象、数组等引用关系逻辑</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A-bind-apply-call\"><span class=\"toc-text\">显示绑定 (bind | apply | call)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98-call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">面试题 call、apply、bind的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%86%99%E9%A2%98-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind\"><span class=\"toc-text\">手写题 实现一个bind</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">3. 闭包</span></a></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"前端知识点之CSS汇总篇","uid":"59630f6cb50b5d1b95c17c1cbb07d624","slug":"前端知识点之CSS汇总篇/index","date":"2023-06-26T16:00:00.000Z","updated":"2023-07-02T02:50:42.527Z","comments":true,"path":"api/articles/前端知识点之CSS汇总篇/index.json","keywords":null,"cover":null,"text":"1. 布局技巧使用text-align-last对其两端文本 使用:not()选择器去除无用属性 多行文本溢出省略号 2. 事件技巧使用pointer-events禁用事件触发，场景：例如背景为地图，上层有图表的大屏看板 使用:hover描绘鼠标跟随 3. 面试题1. absol...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[{"name":"知识点","slug":"知识点","count":9,"path":"api/categories/知识点.json"}],"tags":[{"name":"CSS","slug":"CSS","count":2,"path":"api/tags/CSS.json"},{"name":"面试题","slug":"面试题","count":4,"path":"api/tags/面试题.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}