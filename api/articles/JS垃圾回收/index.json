{"title":"JS 垃圾回收","uid":"997108380504e887eb3e4c9fa356e3bd","slug":"JS垃圾回收/index","date":"2022-04-01T16:00:00.000Z","updated":"2023-07-20T03:08:46.834Z","comments":true,"path":"api/articles/JS垃圾回收/index.json","keywords":null,"cover":null,"content":"<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p>垃圾回收有两种方式：标记清除和引用计数</p>\n<h4 id=\"1-引用计数\"><a href=\"#1-引用计数\" class=\"headerlink\" title=\"1. 引用计数\"></a>1. 引用计数</h4><p>计算所有变量被引用的次数，为0则可以清除</p>\n<p>缺点: 如果两个变量循环引用，则全部无法清除</p>\n<h4 id=\"2-标记清除\"><a href=\"#2-标记清除\" class=\"headerlink\" title=\"2. 标记清除\"></a>2. 标记清除</h4><p>垃圾收集器会在运行时将所有内存中的变量做上标记，尝试从根部触及所有的变量，无法触达的则视为可清除的变量</p>\n<p>从2012年开始，所有现代浏览器都使用了标记清除的方式</p>\n<h4 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h4><h5 id=\"1-全局变量\"><a href=\"#1-全局变量\" class=\"headerlink\" title=\"1. 全局变量\"></a>1. 全局变量</h5><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function demo() &#123;\n    this.field &#x3D; 1;\n&#125;\ndemo(); &#x2F;&#x2F; 这里window对象被添加了一个属性，而未被销毁，该变量从全局出发可以通过window触达，所以无法被回收</code></pre>\n\n<h5 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h5><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function demo() &#123;\n    let num &#x3D; 1;\n    return () &#x3D;&gt; &#123;\n        console.log(num++);\n    &#125;\n&#125;\ndemo()();       &#x2F;&#x2F; 1\ndemo()();       &#x2F;&#x2F; 1\n\nlet fn &#x3D; demo();\nfn();           &#x2F;&#x2F; 1\ndemo()();       &#x2F;&#x2F; 1\nfn();           &#x2F;&#x2F; 2\nfn &#x3D; null;\nfn &#x3D; demo();\nfn();           &#x2F;&#x2F; 1</code></pre>\n\n<p>这里在<code>demo</code>函数的闭包被直接调用时，会被认为没有其他内容可以继续触达<code>num</code>变量，所以内存被释放，再次调用还会打印1，然而当我们把<code>demo</code>函数返回的闭包函数接收下来时，则一直有内容可以触达<code>num</code>变量，所以再次打印结果为2，我们可以通过赋值为<code>null</code>的方式手动清空内存</p>\n<h5 id=\"3-DOM-引用\"><a href=\"#3-DOM-引用\" class=\"headerlink\" title=\"3. DOM 引用\"></a>3. DOM 引用</h5><p>在js中有对Dom的引用，然而Dom已经销毁，此时其实对其引用已经没有作用，但仍然无法被销毁</p>\n<h4 id=\"避免方案\"><a href=\"#避免方案\" class=\"headerlink\" title=\"避免方案\"></a>避免方案</h4><ol>\n<li>小心谨慎地使用全局变量</li>\n<li>使用闭包时要注意</li>\n<li>计时器里的回调没用时要记得销毁</li>\n<li>可以使用<code>WeakSet</code>和<code>WeakMap</code>，它们对于值的使用都是不计入垃圾回收机制的，表示为弱引用</li>\n</ol>\n","text":"垃圾回收机制垃圾回收有两种方式：标记清除和引用计数 1. 引用计数计算所有变量被引用的次数，为0则可以清除 缺点: 如果两个变量循环引用，则全部无法清除 2. 标记清除垃圾收集器会在运行时将所有内存中的变量做上标记，尝试从根部触及所有的变量，无法触达的则视为可清除的变量 从201...","link":"","photos":[],"count_time":{"symbolsCount":959,"symbolsTime":"1 mins."},"categories":[{"name":"效率优化","slug":"效率优化","count":5,"path":"api/categories/效率优化.json"}],"tags":[{"name":"JS","slug":"JS","count":4,"path":"api/tags/JS.json"},{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">1. 引用计数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4\"><span class=\"toc-text\">2. 标记清除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">内存泄漏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1. 全局变量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">2. 闭包</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-DOM-%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">3. DOM 引用</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">避免方案</span></a></li></ol></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"layui bug记录","uid":"bec3eed037605986e82f30f910c0b6ea","slug":"layui-bug记录/index","date":"2022-04-13T16:00:00.000Z","updated":"2023-04-06T06:04:13.793Z","comments":true,"path":"api/articles/layui-bug记录/index.json","keywords":null,"cover":null,"text":"首次加载弹框时，背景闪白问题 原因：源码layui.css中，存在样式： .layui-layer-load &#123; background: url(loading-1.gif) center center no-repeat #eee; &#125; 修改样式中颜色即可 ...","link":"","photos":[],"count_time":{"symbolsCount":271,"symbolsTime":"1 mins."},"categories":[{"name":"bug","slug":"bug","count":6,"path":"api/categories/bug.json"}],"tags":[{"name":"bug","slug":"bug","count":6,"path":"api/tags/bug.json"},{"name":"layui","slug":"layui","count":1,"path":"api/tags/layui.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Cookie和Token令牌","uid":"d4d5e8b67369f1d79a080e310bf56e19","slug":"Cookie和Token令牌/index","date":"2022-02-14T16:00:00.000Z","updated":"2023-05-08T08:30:40.513Z","comments":true,"path":"api/articles/Cookie和Token令牌/index.json","keywords":null,"cover":[],"text":"什么是Cookie？为什么要有Cookie？ 一般接口但是通过HTTP协议来进行数据交换的，而HTTP协议的特点是，无状态，工作前通过三次握手建立连接，工作完成后立刻通过四次挥手断开连接，每次连接都是独立存在的，没有任何状态将请求串联成一个整体，因此每次都需要重新验证是身份，即耗...","link":"","photos":[],"count_time":{"symbolsCount":885,"symbolsTime":"1 mins."},"categories":[{"name":"知识点","slug":"知识点","count":10,"path":"api/categories/知识点.json"}],"tags":[{"name":"Cookie","slug":"Cookie","count":1,"path":"api/tags/Cookie.json"},{"name":"Token令牌","slug":"Token令牌","count":1,"path":"api/tags/Token令牌.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}