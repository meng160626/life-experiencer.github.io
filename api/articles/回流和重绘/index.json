{"title":"回流和重绘","uid":"252d505e28324426d832f92b75665197","slug":"回流和重绘/index","date":"2023-01-03T16:00:00.000Z","updated":"2023-07-17T06:11:56.277Z","comments":true,"path":"api/articles/回流和重绘/index.json","keywords":null,"cover":null,"content":"<h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p>浏览器采用流式布局模型。<br>通过把<code>HTML</code>解析成<code>DOM</code> <code>CSS</code>解析成<code>CSSOM</code> <code>DOM</code>和<code>CSSOM</code>合并成<code>Render Tree</code>渲染树。<br>有了<code>Render Tree</code>就知道了所有节点的样式，再计算大小和位置，最后绘制在页面上。</p>\n<p>通常计算流式布局只需要一次，但<code>table</code>及其内部元素除外，他们需要通过多次计算，所以要避免使用<code>table</code>布局。、</p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>,<code>visibility</code>,<code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证<code>DOM</code>树上其他节点元素的可见性。</p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及<code>DOM</code>中紧随其后的节点、祖先节点元素的随后的回流。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>回流必定重绘 重绘未必回流</p>\n</div>\n<h3 id=\"如何优化\"><a href=\"#如何优化\" class=\"headerlink\" title=\"如何优化\"></a>如何优化</h3><h4 id=\"浏览器角度\"><a href=\"#浏览器角度\" class=\"headerlink\" title=\"浏览器角度\"></a>浏览器角度</h4><p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。<br>主要包括以下属性或方法：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1、<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code><br>2、<code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code><br>3、<code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code><br>4、<code>width</code>、<code>height</code><br>5、<code>getComputedStyle()</code><br>6、<code>getBoundingClientRect()</code></p></blockquote>\n<p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。</p>\n<h4 id=\"CSS角度\"><a href=\"#CSS角度\" class=\"headerlink\" title=\"CSS角度\"></a>CSS角度</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1、使用<code>transform</code>替代<code>top</code><br>2、使用<code>visibility</code>替换<code>display: none</code>，因为前者只会引起重绘，后者会引发回流（改变了布局<br>3、避免使用<code>table</code>布局，可能很小的一个小改动会造成整个<code>table</code>的重新布局<br>4、尽可能在<code>DOM</code>树的最末端改变<code>class</code>，回流是不可避免的，但可以减少其影响。尽可能在<code>DOM</code>树的最末端改变<code>class</code>，可以限制了回流的范围，使其影响尽可能少的节点<br>5、避免设置多层内联样式，<code>CSS</code>选择符从右往左匹配查找，避免节点层级过多</p></blockquote>\n<h4 id=\"JS角度\"><a href=\"#JS角度\" class=\"headerlink\" title=\"JS角度\"></a>JS角度</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1、避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性<br>2、避免频繁操作<code>DOM</code>，创建一个<code>documentFragment(官方提供的虚拟DOM)</code>，在它上面应用所有<code>DOM</code>操作，最后再把它添加到文档中<br>3、避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来<br>4、对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</p></blockquote>\n","text":"浏览器渲染机制浏览器采用流式布局模型。通过把HTML解析成DOM CSS解析成CSSOM DOM和CSSOM合并成Render Tree渲染树。有了Render Tree就知道了所有节点的样式，再计算大小和位置，最后绘制在页面上。 通常计算流式布局只需要一次，但table及其内部...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"效率优化","slug":"效率优化","count":3,"path":"api/categories/效率优化.json"}],"tags":[{"name":"重绘","slug":"重绘","count":1,"path":"api/tags/重绘.json"},{"name":"回流","slug":"回流","count":1,"path":"api/tags/回流.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">浏览器渲染机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%BB%98\"><span class=\"toc-text\">重绘</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">回流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">如何优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%92%E5%BA%A6\"><span class=\"toc-text\">浏览器角度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CSS%E8%A7%92%E5%BA%A6\"><span class=\"toc-text\">CSS角度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JS%E8%A7%92%E5%BA%A6\"><span class=\"toc-text\">JS角度</span></a></li></ol></li></ol>","author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"wangEditor修改高亮文字样式","uid":"b1ff9fa1698c1511850c33cadadfda26","slug":"wangEditor修改高亮文字样式/index","date":"2023-02-09T16:00:00.000Z","updated":"2023-04-09T03:12:37.853Z","comments":true,"path":"api/articles/wangEditor修改高亮文字样式/index.json","keywords":null,"cover":null,"text":"修改wangeditor中所使用的highlight.js的高亮颜色找到 node_modules -&gt; @wangeditor -&gt; editor -&gt; dist -&gt; css -&gt; style.css 在其中搜索要修改的颜色值，直接修改即可 ","link":"","photos":[],"count_time":{"symbolsCount":138,"symbolsTime":"1 mins."},"categories":[{"name":"工具类","slug":"工具类","count":3,"path":"api/categories/工具类.json"}],"tags":[{"name":"wangEditor","slug":"wangEditor","count":1,"path":"api/tags/wangEditor.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"内存泄漏排查记录","uid":"fe07511baca233cfbf08f1c1c1d5d46a","slug":"内存泄漏/index","date":"2022-11-18T16:00:00.000Z","updated":"2023-04-06T05:05:18.672Z","comments":true,"path":"api/articles/内存泄漏/index.json","keywords":null,"cover":null,"text":" 场景 页面长期不关闭后，页面卡死 排查记录 1、打开浏览器开发工具性能监视器 2、操作页面观察js堆大小发现：随着操作次数增加，js堆内存在每次垃圾回收以后逐次增加 3、刷新页面，查看内存，强制触发垃圾回收，拍摄堆快照 4、反复操作页面后，再次拍摄堆快照 5、对比两次快照，打开...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"效率优化","slug":"效率优化","count":3,"path":"api/categories/效率优化.json"}],"tags":[{"name":"内存泄漏","slug":"内存泄漏","count":1,"path":"api/tags/内存泄漏.json"}],"author":{"name":"Life Experiencer","slug":"blog-author","avatar":"https://meng160626.github.io/charts/assets/headshot.cf6ae831.jpg","link":"/","description":"【开始努力最好的时机，就是当下】QQ:1350257855      微信:meng000414","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}